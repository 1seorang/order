"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately";
exports.ids = ["vendor-chunks/@react-stately"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/checkbox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCheckboxGroupState: () => (/* binding */ $587d3ad58be6d31f$export$daff6da51032a415)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {\n    let [selectedValues, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.value, props.defaultValue || [], props.onChange);\n    const state = {\n        value: selectedValues,\n        setValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            setValue(value);\n        },\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isSelected (value) {\n            return selectedValues.includes(value);\n        },\n        addValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));\n        },\n        removeValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n        },\n        toggleValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n            else setValue(selectedValues.concat(value));\n        },\n        validationState: props.validationState,\n        isInvalid: props.isInvalid || props.validationState === \"invalid\"\n    };\n    return state;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFGOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QseUNBQXlDLG9FQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLNEU7QUFDNUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGZhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2NoZWNrYm94L2Rpc3QvaW1wb3J0Lm1qcz8wYjk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRiM251TyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDU4N2QzYWQ1OGJlNmQzMWYkZXhwb3J0JGRhZmY2ZGE1MTAzMmE0MTUocHJvcHMgPSB7fSkge1xuICAgIGxldCBbc2VsZWN0ZWRWYWx1ZXMsIHNldFZhbHVlXSA9ICgwLCAkYjNudU8kdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlIHx8IFtdLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgc2V0VmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlzYWJsZWQ6IHByb3BzLmlzRGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVhZE9ubHk6IHByb3BzLmlzUmVhZE9ubHkgfHwgZmFsc2UsXG4gICAgICAgIGlzU2VsZWN0ZWQgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRWYWx1ZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlVmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5maWx0ZXIoKGV4aXN0aW5nVmFsdWUpPT5leGlzdGluZ1ZhbHVlICE9PSB2YWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVWYWx1ZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmZpbHRlcigoZXhpc3RpbmdWYWx1ZSk9PmV4aXN0aW5nVmFsdWUgIT09IHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uU3RhdGU6IHByb3BzLnZhbGlkYXRpb25TdGF0ZSxcbiAgICAgICAgaXNJbnZhbGlkOiBwcm9wcy5pc0ludmFsaWQgfHwgcHJvcHMudmFsaWRhdGlvblN0YXRlID09PSBcImludmFsaWRcIlxuICAgIH07XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuXG5cblxuXG5leHBvcnQgeyQ1ODdkM2FkNThiZTZkMzFmJGV4cG9ydCRkYWZmNmRhNTEwMzJhNDE1IGFzIHVzZUNoZWNrYm94R3JvdXBTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/collections/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/collections/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollectionBuilder: () => (/* binding */ $eb2240fc39a57fa5$export$bf788dd355e3a401),\n/* harmony export */   Item: () => (/* binding */ $c1d7fb2ec91bae71$export$6d08773d2e66f8f2),\n/* harmony export */   Section: () => (/* binding */ $9fc4852771d079eb$export$6e2c8f0811a474ce),\n/* harmony export */   compareNodeOrder: () => (/* binding */ $c5a24bc478652b5f$export$8c434b3a7a4dad6),\n/* harmony export */   getChildNodes: () => (/* binding */ $c5a24bc478652b5f$export$1005530eda016c13),\n/* harmony export */   getFirstItem: () => (/* binding */ $c5a24bc478652b5f$export$fbdeaa6a76694f71),\n/* harmony export */   getItemCount: () => (/* binding */ $453cc9f0df89c0a5$export$77d5aafae4e095b2),\n/* harmony export */   getLastItem: () => (/* binding */ $c5a24bc478652b5f$export$7475b2c64539e4cf),\n/* harmony export */   getNthItem: () => (/* binding */ $c5a24bc478652b5f$export$5f3398f8733f90e2),\n/* harmony export */   useCollection: () => (/* binding */ $7613b1592d41b092$export$6cd28814d92fa9c9)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $c1d7fb2ec91bae71$var$Item(props) {\n    return null;\n}\n$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {\n    let { childItems: childItems, title: title, children: children } = props;\n    let rendered = props.title || props.children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"] || \"\";\n    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn(\"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.\");\n    yield {\n        type: \"item\",\n        props: props,\n        rendered: rendered,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),\n        *childNodes () {\n            if (childItems) for (let child of childItems)yield {\n                type: \"item\",\n                value: child\n            };\n            else if (title) {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\nfunction $c1d7fb2ec91bae71$var$hasChildItems(props) {\n    if (props.hasChildItems != null) return props.hasChildItems;\n    if (props.childItems) return true;\n    if (props.title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(props.children) > 0) return true;\n    return false;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $9fc4852771d079eb$var$Section(props) {\n    return null;\n}\n$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, title: title, items: items } = props;\n    yield {\n        type: \"section\",\n        props: props,\n        hasChildNodes: true,\n        rendered: title,\n        \"aria-label\": props[\"aria-label\"],\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n// We don't want getCollectionNode to show up in the type definition\nlet $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nclass $eb2240fc39a57fa5$export$bf788dd355e3a401 {\n    build(props, context) {\n        this.context = context;\n        return $eb2240fc39a57fa5$var$iterable(()=>this.iterateCollection(props));\n    }\n    *iterateCollection(props) {\n        let { children: children, items: items } = props;\n        if (typeof children === \"function\") {\n            if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n            for (let item of props.items)yield* this.getFullNode({\n                value: item\n            }, {\n                renderer: children\n            });\n        } else {\n            let items = [];\n            (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                items.push(child);\n            });\n            let index = 0;\n            for (let item of items){\n                let nodes = this.getFullNode({\n                    element: item,\n                    index: index\n                }, {});\n                for (let node of nodes){\n                    index++;\n                    yield node;\n                }\n            }\n        }\n    }\n    getKey(item, partialNode, state, parentKey) {\n        if (item.key != null) return item.key;\n        if (partialNode.type === \"cell\" && partialNode.key != null) return `${parentKey}${partialNode.key}`;\n        let v = partialNode.value;\n        if (v != null) {\n            var _v_key;\n            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;\n            if (key == null) throw new Error(\"No key found for item\");\n            return key;\n        }\n        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n    }\n    getChildState(state, partialNode) {\n        return {\n            renderer: partialNode.renderer || state.renderer\n        };\n    }\n    *getFullNode(partialNode, state, parentKey, parentNode) {\n        // If there's a value instead of an element on the node, and a parent renderer function is available,\n        // use it to render an element for the value.\n        let element = partialNode.element;\n        if (!element && partialNode.value && state && state.renderer) {\n            let cached = this.cache.get(partialNode.value);\n            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n                cached.index = partialNode.index;\n                cached.parentKey = parentNode ? parentNode.key : null;\n                yield cached;\n                return;\n            }\n            element = state.renderer(partialNode.value);\n        }\n        // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n        // Call this function to get a partial node, and recursively build a full node from there.\n        if ((0, react__WEBPACK_IMPORTED_MODULE_0__).isValidElement(element)) {\n            let type = element.type;\n            if (typeof type !== \"function\" && typeof type.getCollectionNode !== \"function\") {\n                let name = typeof element.type === \"function\" ? element.type.name : element.type;\n                throw new Error(`Unknown element <${name}> in collection.`);\n            }\n            let childNodes = type.getCollectionNode(element.props, this.context);\n            let index = partialNode.index;\n            let result = childNodes.next();\n            while(!result.done && result.value){\n                let childNode = result.value;\n                partialNode.index = index;\n                let nodeKey = childNode.key;\n                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);\n                let nodes = this.getFullNode({\n                    ...childNode,\n                    key: nodeKey,\n                    index: index,\n                    wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)\n                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n                let children = [\n                    ...nodes\n                ];\n                for (let node of children){\n                    // Cache the node based on its value\n                    node.value = childNode.value || partialNode.value;\n                    if (node.value) this.cache.set(node.value, node);\n                    // The partial node may have specified a type for the child in order to specify a constraint.\n                    // Verify that the full node that was built recursively matches this type.\n                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);\n                    index++;\n                    yield node;\n                }\n                result = childNodes.next(children);\n            }\n            return;\n        }\n        // Ignore invalid elements\n        if (partialNode.key == null) return;\n        // Create full node\n        let builder = this;\n        let node = {\n            type: partialNode.type,\n            props: partialNode.props,\n            key: partialNode.key,\n            parentKey: parentNode ? parentNode.key : null,\n            value: partialNode.value,\n            level: parentNode ? parentNode.level + 1 : 0,\n            index: partialNode.index,\n            rendered: partialNode.rendered,\n            textValue: partialNode.textValue,\n            \"aria-label\": partialNode[\"aria-label\"],\n            wrapper: partialNode.wrapper,\n            shouldInvalidate: partialNode.shouldInvalidate,\n            hasChildNodes: partialNode.hasChildNodes,\n            childNodes: $eb2240fc39a57fa5$var$iterable(function*() {\n                if (!partialNode.hasChildNodes) return;\n                let index = 0;\n                for (let child of partialNode.childNodes()){\n                    // Ensure child keys are globally unique by prepending the parent node's key\n                    if (child.key != null) // TODO: Remove this line entirely and enforce that users always provide unique keys.\n                    // Currently this line will have issues when a parent has a key `a` and a child with key `bc`\n                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both\n                    // children having a key of `abc`.\n                    child.key = `${node.key}${child.key}`;\n                    child.index = index;\n                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n                    for (let node of nodes){\n                        index++;\n                        yield node;\n                    }\n                }\n            })\n        };\n        yield node;\n    }\n    constructor(){\n        this.cache = new WeakMap();\n    }\n}\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction $eb2240fc39a57fa5$var$iterable(iterator) {\n    let cache = [];\n    let iterable = null;\n    return {\n        *[Symbol.iterator] () {\n            for (let item of cache)yield item;\n            if (!iterable) iterable = iterator();\n            for (let item of iterable){\n                cache.push(item);\n                yield item;\n            }\n        }\n    };\n}\nfunction $eb2240fc39a57fa5$var$compose(outer, inner) {\n    if (outer && inner) return (element)=>outer(inner(element));\n    if (outer) return outer;\n    if (inner) return inner;\n}\nfunction $eb2240fc39a57fa5$var$capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\n\n\n\nfunction $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);\n    let { children: children, items: items, collection: collection } = props;\n    let result = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (collection) return collection;\n        let nodes = builder.build({\n            children: children,\n            items: items\n        }, context);\n        return factory(nodes);\n    }, [\n        builder,\n        children,\n        items,\n        collection,\n        context,\n        factory\n    ]);\n    return result;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n    // New API: call collection.getChildren with the node key.\n    if (typeof collection.getChildren === \"function\") return collection.getChildren(node.key);\n    // Old API: access childNodes directly.\n    return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n    return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n    if (index < 0) return undefined;\n    let i = 0;\n    for (let item of iterable){\n        if (i === index) return item;\n        i++;\n    }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n    let lastItem = undefined;\n    for (let value of iterable)lastItem = value;\n    return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n    // If the two nodes have the same parent, compare their indices.\n    if (a.parentKey === b.parentKey) return a.index - b.index;\n    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n    // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n    // ancestor of the same level\n    let aAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, a),\n        a\n    ];\n    let bAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, b),\n        b\n    ];\n    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);\n    if (firstNonMatchingAncestor !== -1) {\n        // Compare the indices of two children within the common ancestor.\n        a = aAncestors[firstNonMatchingAncestor];\n        b = bAncestors[firstNonMatchingAncestor];\n        return a.index - b.index;\n    }\n    // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n    if (aAncestors.findIndex((node)=>node === b) >= 0) return 1;\n    else if (bAncestors.findIndex((node)=>node === a) >= 0) return -1;\n    // ðŸ¤·\n    return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n    let parents = [];\n    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){\n        node = collection.getItem(node.parentKey);\n        parents.unshift(node);\n    }\n    return parents;\n}\n\n\nconst $453cc9f0df89c0a5$var$cache = new WeakMap();\nfunction $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {\n    let count = $453cc9f0df89c0a5$var$cache.get(collection);\n    if (count != null) return count;\n    count = 0;\n    let countItems = (items)=>{\n        for (let item of items)if (item.type === \"section\") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));\n        else count++;\n    };\n    countItems(collection);\n    $453cc9f0df89c0a5$var$cache.set(collection, count);\n    return count;\n}\n\n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkRBQTJEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaURBQWlEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxvQkFBb0Isa0NBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0EsZ0JBQWdCLGtDQUFZO0FBQzVCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVSxFQUFFLGdCQUFnQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVLEdBQUcsa0JBQWtCLFNBQVMsa0JBQWtCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdURBQXVELFVBQVUsRUFBRSxZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCw0Q0FBNEMsUUFBUSxrREFBa0QsV0FBVyxtREFBbUQ7QUFDclI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUyxFQUFFLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSxzQkFBc0IsMENBQWM7QUFDcEMsVUFBVSwyREFBMkQ7QUFDckUscUJBQXFCLDBDQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPZ2xCO0FBQ2hsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FsZmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzPzgyOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICR0eVc2QSRyZWFjdCwge3VzZU1lbW8gYXMgJHR5VzZBJHVzZU1lbW99IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRJdGVtLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRJdGVtczogY2hpbGRJdGVtcywgdGl0bGU6IHRpdGxlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIGxldCByZW5kZXJlZCA9IHByb3BzLnRpdGxlIHx8IHByb3BzLmNoaWxkcmVuO1xuICAgIGxldCB0ZXh0VmFsdWUgPSBwcm9wcy50ZXh0VmFsdWUgfHwgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJzdHJpbmdcIiA/IHJlbmRlcmVkIDogXCJcIikgfHwgcHJvcHNbXCJhcmlhLWxhYmVsXCJdIHx8IFwiXCI7XG4gICAgLy8gc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nIGlzIHVzZWQgaW4gY29tcG9uZW50cyBsaWtlIFRhYnMsIHdoaWNoIGRvbid0IGhhdmUgdHlwZSB0byBzZWxlY3Qgc3VwcG9ydC5cbiAgICBpZiAoIXRleHRWYWx1ZSAmJiAhKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmcpKSBjb25zb2xlLndhcm4oXCI8SXRlbT4gd2l0aCBub24tcGxhaW4gdGV4dCBjb250ZW50cyBpcyB1bnN1cHBvcnRlZCBieSB0eXBlIHRvIHNlbGVjdCBmb3IgYWNjZXNzaWJpbGl0eS4gUGxlYXNlIGFkZCBhIGB0ZXh0VmFsdWVgIHByb3AuXCIpO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogJGMxZDdmYjJlYzkxYmFlNzEkdmFyJGhhc0NoaWxkSXRlbXMocHJvcHMpLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRJdGVtcykgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRJdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxzZSBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmZ1bmN0aW9uICRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRoYXNDaGlsZEl0ZW1zKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmhhc0NoaWxkSXRlbXMgIT0gbnVsbCkgcmV0dXJuIHByb3BzLmhhc0NoaWxkSXRlbXM7XG4gICAgaWYgKHByb3BzLmNoaWxkSXRlbXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChwcm9wcy50aXRsZSAmJiAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyID0gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW07XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb24ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCB0aXRsZTogdGl0bGUsIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcInNlY3Rpb25cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICByZW5kZXJlZDogdGl0bGUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkOWZjNDg1Mjc3MWQwNzllYiRleHBvcnQkNmUyYzhmMDgxMWE0NzRjZSA9ICQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jbGFzcyAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSB7XG4gICAgYnVpbGQocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZSgoKT0+dGhpcy5pdGVyYXRlQ29sbGVjdGlvbihwcm9wcykpO1xuICAgIH1cbiAgICAqaXRlcmF0ZUNvbGxlY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMgfSA9IHByb3BzO1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBwcm9wcy5pdGVtcyl5aWVsZCogdGhpcy5nZXRGdWxsTm9kZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRLZXkoaXRlbSwgcGFydGlhbE5vZGUsIHN0YXRlLCBwYXJlbnRLZXkpIHtcbiAgICAgICAgaWYgKGl0ZW0ua2V5ICE9IG51bGwpIHJldHVybiBpdGVtLmtleTtcbiAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgPT09IFwiY2VsbFwiICYmIHBhcnRpYWxOb2RlLmtleSAhPSBudWxsKSByZXR1cm4gYCR7cGFyZW50S2V5fSR7cGFydGlhbE5vZGUua2V5fWA7XG4gICAgICAgIGxldCB2ID0gcGFydGlhbE5vZGUudmFsdWU7XG4gICAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfdl9rZXk7XG4gICAgICAgICAgICBsZXQga2V5ID0gKF92X2tleSA9IHYua2V5KSAhPT0gbnVsbCAmJiBfdl9rZXkgIT09IHZvaWQgMCA/IF92X2tleSA6IHYuaWQ7XG4gICAgICAgICAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk5vIGtleSBmb3VuZCBmb3IgaXRlbVwiKTtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudEtleSA/IGAke3BhcmVudEtleX0uJHtwYXJ0aWFsTm9kZS5pbmRleH1gIDogYCQuJHtwYXJ0aWFsTm9kZS5pbmRleH1gO1xuICAgIH1cbiAgICBnZXRDaGlsZFN0YXRlKHN0YXRlLCBwYXJ0aWFsTm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVuZGVyZXI6IHBhcnRpYWxOb2RlLnJlbmRlcmVyIHx8IHN0YXRlLnJlbmRlcmVyXG4gICAgICAgIH07XG4gICAgfVxuICAgICpnZXRGdWxsTm9kZShwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSwgcGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgdmFsdWUgaW5zdGVhZCBvZiBhbiBlbGVtZW50IG9uIHRoZSBub2RlLCBhbmQgYSBwYXJlbnQgcmVuZGVyZXIgZnVuY3Rpb24gaXMgYXZhaWxhYmxlLFxuICAgICAgICAvLyB1c2UgaXQgdG8gcmVuZGVyIGFuIGVsZW1lbnQgZm9yIHRoZSB2YWx1ZS5cbiAgICAgICAgbGV0IGVsZW1lbnQgPSBwYXJ0aWFsTm9kZS5lbGVtZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQgJiYgcGFydGlhbE5vZGUudmFsdWUgJiYgc3RhdGUgJiYgc3RhdGUucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLmNhY2hlLmdldChwYXJ0aWFsTm9kZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmICghY2FjaGVkLnNob3VsZEludmFsaWRhdGUgfHwgIWNhY2hlZC5zaG91bGRJbnZhbGlkYXRlKHRoaXMuY29udGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkLmluZGV4ID0gcGFydGlhbE5vZGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgY2FjaGVkLnBhcmVudEtleSA9IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmtleSA6IG51bGw7XG4gICAgICAgICAgICAgICAgeWllbGQgY2FjaGVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBzdGF0ZS5yZW5kZXJlcihwYXJ0aWFsTm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBlbGVtZW50IHdpdGggYSBnZXRDb2xsZWN0aW9uTm9kZSBmdW5jdGlvbiBvbiBpdHMgdHlwZSwgdGhlbiBpdCdzIGEgc3VwcG9ydGVkIGNvbXBvbmVudC5cbiAgICAgICAgLy8gQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGdldCBhIHBhcnRpYWwgbm9kZSwgYW5kIHJlY3Vyc2l2ZWx5IGJ1aWxkIGEgZnVsbCBub2RlIGZyb20gdGhlcmUuXG4gICAgICAgIGlmICgoMCwgJHR5VzZBJHJlYWN0KS5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdHlwZS5nZXRDb2xsZWN0aW9uTm9kZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2YgZWxlbWVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgPyBlbGVtZW50LnR5cGUubmFtZSA6IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZWxlbWVudCA8JHtuYW1lfT4gaW4gY29sbGVjdGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gdHlwZS5nZXRDb2xsZWN0aW9uTm9kZShlbGVtZW50LnByb3BzLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFydGlhbE5vZGUuaW5kZXg7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gY2hpbGROb2Rlcy5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSghcmVzdWx0LmRvbmUgJiYgcmVzdWx0LnZhbHVlKXtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcnRpYWxOb2RlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVLZXkgPSBjaGlsZE5vZGUua2V5O1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUtleSkgbm9kZUtleSA9IGNoaWxkTm9kZS5lbGVtZW50ID8gbnVsbCA6IHRoaXMuZ2V0S2V5KGVsZW1lbnQsIHBhcnRpYWxOb2RlLCBzdGF0ZSwgcGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGROb2RlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5vZGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlcjogJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2UocGFydGlhbE5vZGUud3JhcHBlciwgY2hpbGROb2RlLndyYXBwZXIpXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5nZXRDaGlsZFN0YXRlKHN0YXRlLCBjaGlsZE5vZGUpLCBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9JHtlbGVtZW50LmtleX1gIDogZWxlbWVudC5rZXksIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZXNcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGRyZW4pe1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgbm9kZSBiYXNlZCBvbiBpdHMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IGNoaWxkTm9kZS52YWx1ZSB8fCBwYXJ0aWFsTm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUpIHRoaXMuY2FjaGUuc2V0KG5vZGUudmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcGFydGlhbCBub2RlIG1heSBoYXZlIHNwZWNpZmllZCBhIHR5cGUgZm9yIHRoZSBjaGlsZCBpbiBvcmRlciB0byBzcGVjaWZ5IGEgY29uc3RyYWludC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGZ1bGwgbm9kZSB0aGF0IHdhcyBidWlsdCByZWN1cnNpdmVseSBtYXRjaGVzIHRoaXMgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgJiYgbm9kZS50eXBlICE9PSBwYXJ0aWFsTm9kZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgPCR7JGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUobm9kZS50eXBlKX0+IGluIDwkeyRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHBhcmVudE5vZGUudHlwZSl9Pi4gT25seSA8JHskZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShwYXJ0aWFsTm9kZS50eXBlKX0+IGlzIHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2hpbGROb2Rlcy5uZXh0KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgaW52YWxpZCBlbGVtZW50c1xuICAgICAgICBpZiAocGFydGlhbE5vZGUua2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGZ1bGwgbm9kZVxuICAgICAgICBsZXQgYnVpbGRlciA9IHRoaXM7XG4gICAgICAgIGxldCBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogcGFydGlhbE5vZGUudHlwZSxcbiAgICAgICAgICAgIHByb3BzOiBwYXJ0aWFsTm9kZS5wcm9wcyxcbiAgICAgICAgICAgIGtleTogcGFydGlhbE5vZGUua2V5LFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5rZXkgOiBudWxsLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnRpYWxOb2RlLnZhbHVlLFxuICAgICAgICAgICAgbGV2ZWw6IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmxldmVsICsgMSA6IDAsXG4gICAgICAgICAgICBpbmRleDogcGFydGlhbE5vZGUuaW5kZXgsXG4gICAgICAgICAgICByZW5kZXJlZDogcGFydGlhbE5vZGUucmVuZGVyZWQsXG4gICAgICAgICAgICB0ZXh0VmFsdWU6IHBhcnRpYWxOb2RlLnRleHRWYWx1ZSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwYXJ0aWFsTm9kZVtcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgICAgICB3cmFwcGVyOiBwYXJ0aWFsTm9kZS53cmFwcGVyLFxuICAgICAgICAgICAgc2hvdWxkSW52YWxpZGF0ZTogcGFydGlhbE5vZGUuc2hvdWxkSW52YWxpZGF0ZSxcbiAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IHBhcnRpYWxOb2RlLmhhc0NoaWxkTm9kZXMsXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFydGlhbE5vZGUuaGFzQ2hpbGROb2RlcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgcGFydGlhbE5vZGUuY2hpbGROb2RlcygpKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNoaWxkIGtleXMgYXJlIGdsb2JhbGx5IHVuaXF1ZSBieSBwcmVwZW5kaW5nIHRoZSBwYXJlbnQgbm9kZSdzIGtleVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIC8vIFRPRE86IFJlbW92ZSB0aGlzIGxpbmUgZW50aXJlbHkgYW5kIGVuZm9yY2UgdGhhdCB1c2VycyBhbHdheXMgcHJvdmlkZSB1bmlxdWUga2V5cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3VycmVudGx5IHRoaXMgbGluZSB3aWxsIGhhdmUgaXNzdWVzIHdoZW4gYSBwYXJlbnQgaGFzIGEga2V5IGBhYCBhbmQgYSBjaGlsZCB3aXRoIGtleSBgYmNgXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBhbm90aGVyIHBhcmVudCBoYXMga2V5IGBhYmAgYW5kIGl0cyBjaGlsZCBoYXMgYSBrZXkgYGNgLiBUaGUgY29tYmluZWQga2V5cyB3b3VsZCByZXN1bHQgaW4gYm90aFxuICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiBoYXZpbmcgYSBrZXkgb2YgYGFiY2AuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmtleSA9IGAke25vZGUua2V5fSR7Y2hpbGQua2V5fWA7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IGJ1aWxkZXIuZ2V0RnVsbE5vZGUoY2hpbGQsIGJ1aWxkZXIuZ2V0Q2hpbGRTdGF0ZShzdGF0ZSwgY2hpbGQpLCBub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG59XG4vLyBXcmFwcyBhbiBpdGVyYXRvciBmdW5jdGlvbiBhcyBhbiBpdGVyYWJsZSBvYmplY3QsIGFuZCBjYWNoZXMgdGhlIHJlc3VsdHMuXG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoaXRlcmF0b3IpIHtcbiAgICBsZXQgY2FjaGUgPSBbXTtcbiAgICBsZXQgaXRlcmFibGUgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGNhY2hlKXlpZWxkIGl0ZW07XG4gICAgICAgICAgICBpZiAoIWl0ZXJhYmxlKSBpdGVyYWJsZSA9IGl0ZXJhdG9yKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhYmxlKXtcbiAgICAgICAgICAgICAgICBjYWNoZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2Uob3V0ZXIsIGlubmVyKSB7XG4gICAgaWYgKG91dGVyICYmIGlubmVyKSByZXR1cm4gKGVsZW1lbnQpPT5vdXRlcihpbm5lcihlbGVtZW50KSk7XG4gICAgaWYgKG91dGVyKSByZXR1cm4gb3V0ZXI7XG4gICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG59XG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuXG5mdW5jdGlvbiAkNzYxM2IxNTkyZDQxYjA5MiRleHBvcnQkNmNkMjg4MTRkOTJmYTljOShwcm9wcywgZmFjdG9yeSwgY29udGV4dCkge1xuICAgIGxldCBidWlsZGVyID0gKDAsICR0eVc2QSR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSkoKSwgW10pO1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgaXRlbXM6IGl0ZW1zLCBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uIH0gPSBwcm9wcztcbiAgICBsZXQgcmVzdWx0ID0gKDAsICR0eVc2QSR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAoY29sbGVjdGlvbikgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIGxldCBub2RlcyA9IGJ1aWxkZXIuYnVpbGQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgaXRlbXM6IGl0ZW1zXG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZmFjdG9yeShub2Rlcyk7XG4gICAgfSwgW1xuICAgICAgICBidWlsZGVyLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGZhY3RvcnlcbiAgICBdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMobm9kZSwgY29sbGVjdGlvbikge1xuICAgIC8vIE5ldyBBUEk6IGNhbGwgY29sbGVjdGlvbi5nZXRDaGlsZHJlbiB3aXRoIHRoZSBub2RlIGtleS5cbiAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24uZ2V0Q2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0Q2hpbGRyZW4obm9kZS5rZXkpO1xuICAgIC8vIE9sZCBBUEk6IGFjY2VzcyBjaGlsZE5vZGVzIGRpcmVjdGx5LlxuICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXM7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkZmJkZWFhNmE3NjY5NGY3MShpdGVyYWJsZSkge1xuICAgIHJldHVybiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMihpdGVyYWJsZSwgMCk7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMihpdGVyYWJsZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhYmxlKXtcbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSByZXR1cm4gaXRlbTtcbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ3NDc1YjJjNjQ1MzllNGNmKGl0ZXJhYmxlKSB7XG4gICAgbGV0IGxhc3RJdGVtID0gdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKWxhc3RJdGVtID0gdmFsdWU7XG4gICAgcmV0dXJuIGxhc3RJdGVtO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNihjb2xsZWN0aW9uLCBhLCBiKSB7XG4gICAgLy8gSWYgdGhlIHR3byBub2RlcyBoYXZlIHRoZSBzYW1lIHBhcmVudCwgY29tcGFyZSB0aGVpciBpbmRpY2VzLlxuICAgIGlmIChhLnBhcmVudEtleSA9PT0gYi5wYXJlbnRLZXkpIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAvLyBPdGhlcndpc2UsIGNvbGxlY3QgYWxsIG9mIHRoZSBhbmNlc3RvcnMgZnJvbSBlYWNoIG5vZGUsIGFuZCBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBkb2Vzbid0IG1hdGNoIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QuXG4gICAgLy8gSW5jbHVkZSB0aGUgYmFzZSBub2RlcyBpbiBjYXNlIHdlIGFyZSBjb21wYXJpbmcgbm9kZXMgb2YgZGlmZmVyZW50IGxldmVscyBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIHRoZSBoaWdoZXIgbm9kZSB0byB0aGUgbG93ZXIgbGV2ZWwgbm9kZSdzXG4gICAgLy8gYW5jZXN0b3Igb2YgdGhlIHNhbWUgbGV2ZWxcbiAgICBsZXQgYUFuY2VzdG9ycyA9IFtcbiAgICAgICAgLi4uJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBhKSxcbiAgICAgICAgYVxuICAgIF07XG4gICAgbGV0IGJBbmNlc3RvcnMgPSBbXG4gICAgICAgIC4uLiRjNWEyNGJjNDc4NjUyYjVmJHZhciRnZXRBbmNlc3RvcnMoY29sbGVjdGlvbiwgYiksXG4gICAgICAgIGJcbiAgICBdO1xuICAgIGxldCBmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3IgPSBhQW5jZXN0b3JzLnNsaWNlKDAsIGJBbmNlc3RvcnMubGVuZ3RoKS5maW5kSW5kZXgoKGEsIGkpPT5hICE9PSBiQW5jZXN0b3JzW2ldKTtcbiAgICBpZiAoZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yICE9PSAtMSkge1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBpbmRpY2VzIG9mIHR3byBjaGlsZHJlbiB3aXRoaW4gdGhlIGNvbW1vbiBhbmNlc3Rvci5cbiAgICAgICAgYSA9IGFBbmNlc3RvcnNbZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yXTtcbiAgICAgICAgYiA9IGJBbmNlc3RvcnNbZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yXTtcbiAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpc24ndCBhIG5vbiBtYXRjaGluZyBhbmNlc3Rvciwgd2UgbWlnaHQgYmUgaW4gYSBjYXNlIHdoZXJlIG9uZSBvZiB0aGUgbm9kZXMgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBvdGhlci5cbiAgICBpZiAoYUFuY2VzdG9ycy5maW5kSW5kZXgoKG5vZGUpPT5ub2RlID09PSBiKSA+PSAwKSByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChiQW5jZXN0b3JzLmZpbmRJbmRleCgobm9kZSk9Pm5vZGUgPT09IGEpID49IDApIHJldHVybiAtMTtcbiAgICAvLyDwn6S3XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBub2RlKSB7XG4gICAgbGV0IHBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnBhcmVudEtleSkgIT0gbnVsbCl7XG4gICAgICAgIG5vZGUgPSBjb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5wYXJlbnRLZXkpO1xuICAgICAgICBwYXJlbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufVxuXG5cbmNvbnN0ICQ0NTNjYzlmMGRmODljMGE1JHZhciRjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkNDUzY2M5ZjBkZjg5YzBhNSRleHBvcnQkNzdkNWFhZmFlNGUwOTViMihjb2xsZWN0aW9uKSB7XG4gICAgbGV0IGNvdW50ID0gJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlLmdldChjb2xsZWN0aW9uKTtcbiAgICBpZiAoY291bnQgIT0gbnVsbCkgcmV0dXJuIGNvdW50O1xuICAgIGNvdW50ID0gMDtcbiAgICBsZXQgY291bnRJdGVtcyA9IChpdGVtcyk9PntcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcylpZiAoaXRlbS50eXBlID09PSBcInNlY3Rpb25cIikgY291bnRJdGVtcygoMCwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMpKGl0ZW0sIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgZWxzZSBjb3VudCsrO1xuICAgIH07XG4gICAgY291bnRJdGVtcyhjb2xsZWN0aW9uKTtcbiAgICAkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUuc2V0KGNvbGxlY3Rpb24sIGNvdW50KTtcbiAgICByZXR1cm4gY291bnQ7XG59XG5cblxuXG5cblxuXG5leHBvcnQgeyRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyIGFzIEl0ZW0sICQ5ZmM0ODUyNzcxZDA3OWViJGV4cG9ydCQ2ZTJjOGYwODExYTQ3NGNlIGFzIFNlY3Rpb24sICQ3NjEzYjE1OTJkNDFiMDkyJGV4cG9ydCQ2Y2QyODgxNGQ5MmZhOWM5IGFzIHVzZUNvbGxlY3Rpb24sICQ0NTNjYzlmMGRmODljMGE1JGV4cG9ydCQ3N2Q1YWFmYWU0ZTA5NWIyIGFzIGdldEl0ZW1Db3VudCwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMgYXMgZ2V0Q2hpbGROb2RlcywgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JGZiZGVhYTZhNzY2OTRmNzEgYXMgZ2V0Rmlyc3RJdGVtLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNzQ3NWIyYzY0NTM5ZTRjZiBhcyBnZXRMYXN0SXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDVmMzM5OGY4NzMzZjkwZTIgYXMgZ2V0TnRoSXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNiBhcyBjb21wYXJlTm9kZU9yZGVyLCAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSBhcyBDb2xsZWN0aW9uQnVpbGRlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/flags/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/flags/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableTableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530),\n/* harmony export */   tableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6)\n/* harmony export */ });\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRzBJO0FBQzFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWxmYS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9mbGFncy9kaXN0L2ltcG9ydC5tanM/NmJmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gbGV0ICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzID0gZmFsc2U7XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCgpIHtcbiAgICAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cyA9IHRydWU7XG59XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMWIwMGNiMTRhOTYxOTRlNigpIHtcbiAgICByZXR1cm4gJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3M7XG59XG5cblxuZXhwb3J0IHskZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCBhcyBlbmFibGVUYWJsZU5lc3RlZFJvd3MsICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IGFzIHRhYmxlTmVzdGVkUm93c307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/grid/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/grid/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ $16805b1b18093c5f$export$de3fdf6493c353d),\n/* harmony export */   useGridState: () => (/* binding */ $62967d126f3aa823$export$4007ac09ff9c68ed)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n    let { collection: collection, focusMode: focusMode } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let setFocusedKey = selectionState.setFocusedKey;\n    selectionState.setFocusedKey = (key, child)=>{\n        // If focusMode is cell and an item is focused, focus a child cell instead.\n        if (focusMode === \"cell\" && key != null) {\n            let item = collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n                var _getLastItem, _getFirstItem;\n                let children = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, collection);\n                if (child === \"last\") key = (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n                else key = (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n            }\n        }\n        setFocusedKey(key, child);\n    };\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const node = cachedCollection.current.getItem(selectionState.focusedKey);\n            const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n            const cachedRows = cachedCollection.current.rows;\n            const rows = collection.rows;\n            const diff = cachedRows.length - rows.length;\n            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n            let newRow;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== \"headerrow\") {\n                    newRow = rows[index];\n                    break;\n                }\n                // Find next, not disabled row.\n                if (index < rows.length - 1) index++;\n                else {\n                    if (index > parentNode.index) index = parentNode.index;\n                    index--;\n                }\n            }\n            if (newRow) {\n                const childNodes = newRow.hasChildNodes ? [\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(newRow, collection)\n                ] : [];\n                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n                selectionState.setFocusedKey(keyToFocus);\n            } else selectionState.setFocusedKey(null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        isKeyboardNavigationDisabled: false,\n        selectionManager: selectionManager\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $16805b1b18093c5f$export$de3fdf6493c353d {\n    *[Symbol.iterator]() {\n        yield* [\n            ...this.rows\n        ];\n    }\n    get size() {\n        return [\n            ...this.rows\n        ].length;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _;\n        return (_ = [\n            ...this.rows\n        ][0]) === null || _ === void 0 ? void 0 : _.key;\n    }\n    getLastKey() {\n        var _rows_;\n        let rows = [\n            ...this.rows\n        ];\n        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(opts){\n        this.keyMap = new Map();\n        this.keyMap = new Map();\n        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n        this.rows = [];\n        let visit = (node)=>{\n            // If the node is the same object as the previous node for the same key,\n            // we can skip this node and its children. We always visit columns though,\n            // because we depend on order to build the columns array.\n            let prevNode = this.keyMap.get(node.key);\n            if (opts.visitNode) node = opts.visitNode(node);\n            this.keyMap.set(node.key, node);\n            let childKeys = new Set();\n            let last;\n            for (let child of node.childNodes){\n                if (child.type === \"cell\" && child.parentKey == null) // if child is a cell parent key isn't already established by the collection, match child node to parent row\n                child.parentKey = node.key;\n                childKeys.add(child.key);\n                if (last) {\n                    last.nextKey = child.key;\n                    child.prevKey = last.key;\n                } else child.prevKey = null;\n                visit(child);\n                last = child;\n            }\n            if (last) last.nextKey = null;\n            // Remove deleted nodes and their children from the key map\n            if (prevNode) {\n                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);\n            }\n        };\n        let remove = (node)=>{\n            this.keyMap.delete(node.key);\n            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);\n        };\n        let last;\n        opts.items.forEach((node, i)=>{\n            let rowNode = {\n                level: 0,\n                key: \"row-\" + i,\n                type: \"row\",\n                value: undefined,\n                hasChildNodes: true,\n                childNodes: [\n                    ...node.childNodes\n                ],\n                rendered: undefined,\n                textValue: undefined,\n                ...node\n            };\n            if (last) {\n                last.nextKey = rowNode.key;\n                rowNode.prevKey = last.key;\n            } else rowNode.prevKey = null;\n            this.rows.push(rowNode);\n            visit(rowNode);\n            last = rowNode;\n        });\n        if (last) last.nextKey = null;\n    }\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUo7QUFDakQ7QUFDNEM7O0FBRXBKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVSwrQ0FBK0M7QUFDekQsNkJBQTZCLCtFQUFnQztBQUM3RCwyQkFBMkIsMENBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFFQUFvQjtBQUN2RCxnRUFBZ0UsbUVBQWtCO0FBQ2xGLGdEQUFnRCxvRUFBbUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQWMsY0FBYyxzRUFBdUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQWE7QUFDOUMsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7QUFLK0g7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGZhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2dyaWQvZGlzdC9pbXBvcnQubWpzPzQ3MmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRjQW41ZiRnZXRDaGlsZE5vZGVzLCBnZXRMYXN0SXRlbSBhcyAkY0FuNWYkZ2V0TGFzdEl0ZW0sIGdldEZpcnN0SXRlbSBhcyAkY0FuNWYkZ2V0Rmlyc3RJdGVtfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkY0FuNWYkdXNlTWVtbywgdXNlUmVmIGFzICRjQW41ZiR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkY0FuNWYkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSBhcyAkY0FuNWYkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgU2VsZWN0aW9uTWFuYWdlciBhcyAkY0FuNWYkU2VsZWN0aW9uTWFuYWdlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvblwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJDYyOTY3ZDEyNmYzYWE4MjMkZXhwb3J0JDQwMDdhYzA5ZmY5YzY4ZWQocHJvcHMpIHtcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBmb2N1c01vZGU6IGZvY3VzTW9kZSB9ID0gcHJvcHM7XG4gICAgbGV0IHNlbGVjdGlvblN0YXRlID0gKDAsICRjQW41ZiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGRpc2FibGVkS2V5cyA9ICgwLCAkY0FuNWYkdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgc2V0Rm9jdXNlZEtleSA9IHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXk7XG4gICAgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleSA9IChrZXksIGNoaWxkKT0+e1xuICAgICAgICAvLyBJZiBmb2N1c01vZGUgaXMgY2VsbCBhbmQgYW4gaXRlbSBpcyBmb2N1c2VkLCBmb2N1cyBhIGNoaWxkIGNlbGwgaW5zdGVhZC5cbiAgICAgICAgaWYgKGZvY3VzTW9kZSA9PT0gXCJjZWxsXCIgJiYga2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbS50eXBlKSA9PT0gXCJpdGVtXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dldExhc3RJdGVtLCBfZ2V0Rmlyc3RJdGVtO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9ICgwLCAkY0FuNWYkZ2V0Q2hpbGROb2RlcykoaXRlbSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSBcImxhc3RcIikga2V5ID0gKF9nZXRMYXN0SXRlbSA9ICgwLCAkY0FuNWYkZ2V0TGFzdEl0ZW0pKGNoaWxkcmVuKSkgPT09IG51bGwgfHwgX2dldExhc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0TGFzdEl0ZW0ua2V5O1xuICAgICAgICAgICAgICAgIGVsc2Uga2V5ID0gKF9nZXRGaXJzdEl0ZW0gPSAoMCwgJGNBbjVmJGdldEZpcnN0SXRlbSkoY2hpbGRyZW4pKSA9PT0gbnVsbCB8fCBfZ2V0Rmlyc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Rmlyc3RJdGVtLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRGb2N1c2VkS2V5KGtleSwgY2hpbGQpO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGlvbk1hbmFnZXIgPSAoMCwgJGNBbjVmJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRjQW41ZiRTZWxlY3Rpb25NYW5hZ2VyKShjb2xsZWN0aW9uLCBzZWxlY3Rpb25TdGF0ZSksIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGVcbiAgICBdKTtcbiAgICAvLyBSZXNldCBmb2N1c2VkIGtleSBpZiB0aGF0IGl0ZW0gaXMgZGVsZXRlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgIGNvbnN0IGNhY2hlZENvbGxlY3Rpb24gPSAoMCwgJGNBbjVmJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICRjQW41ZiR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5ICE9IG51bGwgJiYgIWNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50S2V5ICE9IG51bGwgJiYgKG5vZGUudHlwZSA9PT0gXCJjZWxsXCIgfHwgbm9kZS50eXBlID09PSBcInJvd2hlYWRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJjb2x1bW5cIikgPyBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0SXRlbShub2RlLnBhcmVudEtleSkgOiBub2RlO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkUm93cyA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5yb3dzO1xuICAgICAgICAgICAgY29uc3Qgcm93cyA9IGNvbGxlY3Rpb24ucm93cztcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjYWNoZWRSb3dzLmxlbmd0aCAtIHJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5taW4oZGlmZiA+IDEgPyBNYXRoLm1heChwYXJlbnROb2RlLmluZGV4IC0gZGlmZiArIDEsIDApIDogcGFyZW50Tm9kZS5pbmRleCwgcm93cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGxldCBuZXdSb3c7XG4gICAgICAgICAgICB3aGlsZShpbmRleCA+PSAwKXtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbk1hbmFnZXIuaXNEaXNhYmxlZChyb3dzW2luZGV4XS5rZXkpICYmIHJvd3NbaW5kZXhdLnR5cGUgIT09IFwiaGVhZGVycm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93ID0gcm93c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQsIG5vdCBkaXNhYmxlZCByb3cuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcm93cy5sZW5ndGggLSAxKSBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnROb2RlLmluZGV4KSBpbmRleCA9IHBhcmVudE5vZGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1Jvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBuZXdSb3cuaGFzQ2hpbGROb2RlcyA/IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKDAsICRjQW41ZiRnZXRDaGlsZE5vZGVzKShuZXdSb3csIGNvbGxlY3Rpb24pXG4gICAgICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVRvRm9jdXMgPSBuZXdSb3cuaGFzQ2hpbGROb2RlcyAmJiBwYXJlbnROb2RlICE9PSBub2RlICYmIG5vZGUuaW5kZXggPCBjaGlsZE5vZGVzLmxlbmd0aCA/IGNoaWxkTm9kZXNbbm9kZS5pbmRleF0ua2V5IDogbmV3Um93LmtleTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KGtleVRvRm9jdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50ID0gY29sbGVjdGlvbjtcbiAgICB9LCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5XG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIGlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyXG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDE2ODA1YjFiMTgwOTNjNWYkZXhwb3J0JGRlM2ZkZjY0OTNjMzUzZCB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF0ubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHZhciBfO1xuICAgICAgICByZXR1cm4gKF8gPSBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXVswXSkgPT09IG51bGwgfHwgXyA9PT0gdm9pZCAwID8gdm9pZCAwIDogXy5rZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHZhciBfcm93c187XG4gICAgICAgIGxldCByb3dzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoX3Jvd3NfID0gcm93c1tyb3dzLmxlbmd0aCAtIDFdKSA9PT0gbnVsbCB8fCBfcm93c18gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yb3dzXy5rZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5Db3VudCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5jb2x1bW5Db3VudDtcbiAgICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgICAgIGxldCB2aXNpdCA9IChub2RlKT0+e1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgdGhlIHNhbWUgb2JqZWN0IGFzIHRoZSBwcmV2aW91cyBub2RlIGZvciB0aGUgc2FtZSBrZXksXG4gICAgICAgICAgICAvLyB3ZSBjYW4gc2tpcCB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gV2UgYWx3YXlzIHZpc2l0IGNvbHVtbnMgdGhvdWdoLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkZXBlbmQgb24gb3JkZXIgdG8gYnVpbGQgdGhlIGNvbHVtbnMgYXJyYXkuXG4gICAgICAgICAgICBsZXQgcHJldk5vZGUgPSB0aGlzLmtleU1hcC5nZXQobm9kZS5rZXkpO1xuICAgICAgICAgICAgaWYgKG9wdHMudmlzaXROb2RlKSBub2RlID0gb3B0cy52aXNpdE5vZGUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgbGV0IGNoaWxkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGxldCBsYXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJjZWxsXCIgJiYgY2hpbGQucGFyZW50S2V5ID09IG51bGwpIC8vIGlmIGNoaWxkIGlzIGEgY2VsbCBwYXJlbnQga2V5IGlzbid0IGFscmVhZHkgZXN0YWJsaXNoZWQgYnkgdGhlIGNvbGxlY3Rpb24sIG1hdGNoIGNoaWxkIG5vZGUgdG8gcGFyZW50IHJvd1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgICAgIGNoaWxkS2V5cy5hZGQoY2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgY2hpbGQucHJldktleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmlzaXQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGxhc3QgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgbm9kZXMgYW5kIHRoZWlyIGNoaWxkcmVuIGZyb20gdGhlIGtleSBtYXBcbiAgICAgICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHByZXZOb2RlLmNoaWxkTm9kZXMpaWYgKCFjaGlsZEtleXMuaGFzKGNoaWxkLmtleSkpIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCByZW1vdmUgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLmRlbGV0ZShub2RlLmtleSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpaWYgKHRoaXMua2V5TWFwLmdldChjaGlsZC5rZXkpID09PSBjaGlsZCkgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIG9wdHMuaXRlbXMuZm9yRWFjaCgobm9kZSwgaSk9PntcbiAgICAgICAgICAgIGxldCByb3dOb2RlID0ge1xuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgICAgIGtleTogXCJyb3ctXCIgKyBpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwicm93XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5jaGlsZE5vZGVzXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLm5vZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IHJvd05vZGUua2V5O1xuICAgICAgICAgICAgICAgIHJvd05vZGUucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgfSBlbHNlIHJvd05vZGUucHJldktleSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChyb3dOb2RlKTtcbiAgICAgICAgICAgIHZpc2l0KHJvd05vZGUpO1xuICAgICAgICAgICAgbGFzdCA9IHJvd05vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCB7JDYyOTY3ZDEyNmYzYWE4MjMkZXhwb3J0JDQwMDdhYzA5ZmY5YzY4ZWQgYXMgdXNlR3JpZFN0YXRlLCAkMTY4MDViMWIxODA5M2M1ZiRleHBvcnQkZGUzZmRmNjQ5M2MzNTNkIGFzIEdyaWRDb2xsZWN0aW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/list/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/list/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListCollection: () => (/* binding */ $a02d57049d202695$export$d085fb9e920b5ca7),\n/* harmony export */   useListState: () => (/* binding */ $e72dd72e1c76a225$export$2f645645f7bca764),\n/* harmony export */   useSingleSelectListState: () => (/* binding */ $a0d645289fe9b86b$export$e7f05e985daf4b5f)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $a02d57049d202695$export$d085fb9e920b5ca7 {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(nodes){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && node.type === \"section\") for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\n\n\n\n\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n    let { filter: filter } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let factory = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [\n        filter\n    ]);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            suppressTextValueWarning: props.suppressTextValueWarning\n        }), [\n        props.suppressTextValueWarning\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, factory, context);\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n            const cachedItemNodes = [\n                ...cachedCollection.current.getKeys()\n            ].map((key)=>{\n                const itemNode = cachedCollection.current.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const itemNodes = [\n                ...collection.getKeys()\n            ].map((key)=>{\n                const itemNode = collection.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const diff = cachedItemNodes.length - itemNodes.length;\n            let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n            let newNode;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(itemNodes[index].key)) {\n                    newNode = itemNodes[index];\n                    break;\n                }\n                // Find next, not disabled item.\n                if (index < itemNodes.length - 1) index++;\n                else {\n                    if (index > startItem.index) index = startItem.index;\n                    index--;\n                }\n            }\n            selectionState.setFocusedKey(newNode ? newNode.key : null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {\n    var _props_defaultSelectedKey;\n    let [selectedKey, setSelectedKey] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);\n    let selectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectedKey != null ? [\n            selectedKey\n        ] : [], [\n        selectedKey\n    ]);\n    let { collection: collection, disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({\n        ...props,\n        selectionMode: \"single\",\n        disallowEmptySelection: true,\n        allowDuplicateSelectionEvents: true,\n        selectedKeys: selectedKeys,\n        onSelectionChange: (keys)=>{\n            var _keys_values_next_value;\n            let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;\n            // Always fire onSelectionChange, even if the key is the same\n            // as the current key (useControlledState does not).\n            if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);\n            setSelectedKey(key);\n        }\n    });\n    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        selectedItem: selectedItem\n    };\n}\n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGlzdC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEySTtBQUNTO0FBQ25FO0FBQ0k7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLDZCQUE2QiwrRUFBZ0M7QUFDN0QsMkJBQTJCLDBDQUFjO0FBQ3pDO0FBQ0E7QUFDQSxzQkFBc0IsOENBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxzQkFBc0IsMENBQWM7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QixxRUFBb0I7QUFDN0MsK0JBQStCLDBDQUFjLGNBQWMsc0VBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUFhO0FBQzlDLFFBQVEsNENBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0Q0FBNEMsb0VBQXlCO0FBQ3JFLDJCQUEyQiwwQ0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUZBQXlGO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNdU07QUFDdk0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGZhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xpc3QvZGlzdC9pbXBvcnQubWpzPzk0YmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VNZW1vIGFzICQ1OFBocyR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkNThQaHMkdXNlQ2FsbGJhY2ssIHVzZVJlZiBhcyAkNThQaHMkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDU4UGhzJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUgYXMgJDU4UGhzJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsIFNlbGVjdGlvbk1hbmFnZXIgYXMgJDU4UGhzJFNlbGVjdGlvbk1hbmFnZXJ9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb25cIjtcbmltcG9ydCB7dXNlQ29sbGVjdGlvbiBhcyAkNThQaHMkdXNlQ29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkNThQaHMkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNyB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5pdGVyYWJsZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5zaXplO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0S2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0S2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuY2hpbGROb2RlcykgfHwgW107XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5vZGVzKXtcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBub2RlcztcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgICAgICB0aGlzLmtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLnR5cGUgPT09IFwic2VjdGlvblwiKSBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXZpc2l0KG5vZGUpO1xuICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbm9kZV0gb2YgdGhpcy5rZXlNYXApe1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIpIG5vZGUuaW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgICAgbGFzdCA9IG5vZGU7XG4gICAgICAgICAgICAvLyBTZXQgbmV4dEtleSBhcyB1bmRlZmluZWQgc2luY2UgdGhpcyBtaWdodCBiZSB0aGUgbGFzdCBub2RlXG4gICAgICAgICAgICAvLyBJZiBpdCBpc24ndCB0aGUgbGFzdCBub2RlLCBsYXN0Lm5leHRLZXkgd2lsbCBwcm9wZXJseSBzZXQgYXQgc3RhcnQgb2YgbmV3IGxvb3BcbiAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RLZXkgPSBsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3Qua2V5O1xuICAgIH1cbn1cblxuXG5cblxuZnVuY3Rpb24gJGU3MmRkNzJlMWM3NmEyMjUkZXhwb3J0JDJmNjQ1NjQ1ZjdiY2E3NjQocHJvcHMpIHtcbiAgICBsZXQgeyBmaWx0ZXI6IGZpbHRlciB9ID0gcHJvcHM7XG4gICAgbGV0IHNlbGVjdGlvblN0YXRlID0gKDAsICQ1OFBocyR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGRpc2FibGVkS2V5cyA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgZmFjdG9yeSA9ICgwLCAkNThQaHMkdXNlQ2FsbGJhY2spKChub2Rlcyk9PmZpbHRlciA/IG5ldyAoMCwgJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTcpKGZpbHRlcihub2RlcykpIDogbmV3ICgwLCAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNykobm9kZXMpLCBbXG4gICAgICAgIGZpbHRlclxuICAgIF0pO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHN1cHByZXNzVGV4dFZhbHVlV2FybmluZzogcHJvcHMuc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nXG4gICAgICAgIH0pLCBbXG4gICAgICAgIHByb3BzLnN1cHByZXNzVGV4dFZhbHVlV2FybmluZ1xuICAgIF0pO1xuICAgIGxldCBjb2xsZWN0aW9uID0gKDAsICQ1OFBocyR1c2VDb2xsZWN0aW9uKShwcm9wcywgZmFjdG9yeSwgY29udGV4dCk7XG4gICAgbGV0IHNlbGVjdGlvbk1hbmFnZXIgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQ1OFBocyRTZWxlY3Rpb25NYW5hZ2VyKShjb2xsZWN0aW9uLCBzZWxlY3Rpb25TdGF0ZSksIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGVcbiAgICBdKTtcbiAgICAvLyBSZXNldCBmb2N1c2VkIGtleSBpZiB0aGF0IGl0ZW0gaXMgZGVsZXRlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgIGNvbnN0IGNhY2hlZENvbGxlY3Rpb24gPSAoMCwgJDU4UGhzJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICQ1OFBocyR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5ICE9IG51bGwgJiYgIWNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJdGVtID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRJdGVtTm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEtleXMoKVxuICAgICAgICAgICAgXS5tYXAoKGtleSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtTm9kZSA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1Ob2RlLnR5cGUgPT09IFwiaXRlbVwiID8gaXRlbU5vZGUgOiBudWxsO1xuICAgICAgICAgICAgfSkuZmlsdGVyKChub2RlKT0+bm9kZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBpdGVtTm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY29sbGVjdGlvbi5nZXRLZXlzKClcbiAgICAgICAgICAgIF0ubWFwKChrZXkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBjb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbU5vZGUudHlwZSA9PT0gXCJpdGVtXCIgPyBpdGVtTm9kZSA6IG51bGw7XG4gICAgICAgICAgICB9KS5maWx0ZXIoKG5vZGUpPT5ub2RlICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjYWNoZWRJdGVtTm9kZXMubGVuZ3RoIC0gaXRlbU5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IE1hdGgubWluKGRpZmYgPiAxID8gTWF0aC5tYXgoc3RhcnRJdGVtLmluZGV4IC0gZGlmZiArIDEsIDApIDogc3RhcnRJdGVtLmluZGV4LCBpdGVtTm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlKGluZGV4ID49IDApe1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uTWFuYWdlci5pc0Rpc2FibGVkKGl0ZW1Ob2Rlc1tpbmRleF0ua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gaXRlbU5vZGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmQgbmV4dCwgbm90IGRpc2FibGVkIGl0ZW0uXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgaXRlbU5vZGVzLmxlbmd0aCAtIDEpIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IHN0YXJ0SXRlbS5pbmRleCkgaW5kZXggPSBzdGFydEl0ZW0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShuZXdOb2RlID8gbmV3Tm9kZS5rZXkgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQgPSBjb2xsZWN0aW9uO1xuICAgIH0sIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXlcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlclxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICRhMGQ2NDUyODlmZTliODZiJGV4cG9ydCRlN2YwNWU5ODVkYWY0YjVmKHByb3BzKSB7XG4gICAgdmFyIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXk7XG4gICAgbGV0IFtzZWxlY3RlZEtleSwgc2V0U2VsZWN0ZWRLZXldID0gKDAsICQ1OFBocyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnNlbGVjdGVkS2V5LCAoX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA9IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA6IG51bGwsIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICBsZXQgc2VsZWN0ZWRLZXlzID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+c2VsZWN0ZWRLZXkgIT0gbnVsbCA/IFtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5XG4gICAgICAgIF0gOiBbXSwgW1xuICAgICAgICBzZWxlY3RlZEtleVxuICAgIF0pO1xuICAgIGxldCB7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyIH0gPSAoMCwgJGU3MmRkNzJlMWM3NmEyMjUkZXhwb3J0JDJmNjQ1NjQ1ZjdiY2E3NjQpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGU6IFwic2luZ2xlXCIsXG4gICAgICAgIGRpc2FsbG93RW1wdHlTZWxlY3Rpb246IHRydWUsXG4gICAgICAgIGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5cyxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U6IChrZXlzKT0+e1xuICAgICAgICAgICAgdmFyIF9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlO1xuICAgICAgICAgICAgbGV0IGtleSA9IChfa2V5c192YWx1ZXNfbmV4dF92YWx1ZSA9IGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKSAhPT0gbnVsbCAmJiBfa2V5c192YWx1ZXNfbmV4dF92YWx1ZSAhPT0gdm9pZCAwID8gX2tleXNfdmFsdWVzX25leHRfdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgLy8gQWx3YXlzIGZpcmUgb25TZWxlY3Rpb25DaGFuZ2UsIGV2ZW4gaWYgdGhlIGtleSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gYXMgdGhlIGN1cnJlbnQga2V5ICh1c2VDb250cm9sbGVkU3RhdGUgZG9lcyBub3QpLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gc2VsZWN0ZWRLZXkgJiYgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2UpIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKGtleSk7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEtleShrZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkS2V5ICE9IG51bGwgPyBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5LFxuICAgICAgICBzZXRTZWxlY3RlZEtleTogc2V0U2VsZWN0ZWRLZXksXG4gICAgICAgIHNlbGVjdGVkSXRlbTogc2VsZWN0ZWRJdGVtXG4gICAgfTtcbn1cblxuXG5cblxuXG5leHBvcnQgeyRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0IGFzIHVzZUxpc3RTdGF0ZSwgJGEwZDY0NTI4OWZlOWI4NmIkZXhwb3J0JGU3ZjA1ZTk4NWRhZjRiNWYgYXMgdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlLCAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNyBhcyBMaXN0Q29sbGVjdGlvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/list/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/menu/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/menu/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMenuTriggerState: () => (/* binding */ $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)\n/* harmony export */ });\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {\n    let overlayTriggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    return {\n        focusStrategy: focusStrategy,\n        ...overlayTriggerState,\n        open (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.open();\n        },\n        toggle (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.toggle();\n        }\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdHO0FBQzlDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsMkVBQTZCO0FBQy9ELGdEQUFnRCwyQ0FBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUswRTtBQUMxRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FsZmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanM/NzQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU92ZXJsYXlUcmlnZ2VyU3RhdGUgYXMgJDlYdm9oJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9vdmVybGF5c1wiO1xuaW1wb3J0IHt1c2VTdGF0ZSBhcyAkOVh2b2gkdXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkYTI4YzkwM2VlOWFkOGRjNSRleHBvcnQkNzlmZWZlYjFjMjA5MWFjMyhwcm9wcykge1xuICAgIGxldCBvdmVybGF5VHJpZ2dlclN0YXRlID0gKDAsICQ5WHZvaCR1c2VPdmVybGF5VHJpZ2dlclN0YXRlKShwcm9wcyk7XG4gICAgbGV0IFtmb2N1c1N0cmF0ZWd5LCBzZXRGb2N1c1N0cmF0ZWd5XSA9ICgwLCAkOVh2b2gkdXNlU3RhdGUpKG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzU3RyYXRlZ3k6IGZvY3VzU3RyYXRlZ3ksXG4gICAgICAgIC4uLm92ZXJsYXlUcmlnZ2VyU3RhdGUsXG4gICAgICAgIG9wZW4gKGZvY3VzU3RyYXRlZ3kgPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICAgICAgb3ZlcmxheVRyaWdnZXJTdGF0ZS5vcGVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZSAoZm9jdXNTdHJhdGVneSA9IG51bGwpIHtcbiAgICAgICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskYTI4YzkwM2VlOWFkOGRjNSRleHBvcnQkNzlmZWZlYjFjMjA5MWFjMyBhcyB1c2VNZW51VHJpZ2dlclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/menu/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/overlays/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOverlayTriggerState: () => (/* binding */ $fc909762b330b746$export$61c6a8c84e605fb6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUM2Qjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG9FQUF5QjtBQUN6RCxxQkFBcUIsOENBQWtCO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsOENBQWtCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsOENBQWtCO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBSzZFO0FBQzdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWxmYS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9vdmVybGF5cy9kaXN0L2ltcG9ydC5tanM/NGEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUNhbGxiYWNrIGFzICQ0b0EzUCR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkNG9BM1AkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJGZjOTA5NzYyYjMzMGI3NDYkZXhwb3J0JDYxYzZhOGM4NGU2MDVmYjYocHJvcHMpIHtcbiAgICBsZXQgW2lzT3Blbiwgc2V0T3Blbl0gPSAoMCwgJDRvQTNQJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuaXNPcGVuLCBwcm9wcy5kZWZhdWx0T3BlbiB8fCBmYWxzZSwgcHJvcHMub25PcGVuQ2hhbmdlKTtcbiAgICBjb25zdCBvcGVuID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3Blbih0cnVlKTtcbiAgICB9LCBbXG4gICAgICAgIHNldE9wZW5cbiAgICBdKTtcbiAgICBjb25zdCBjbG9zZSA9ICgwLCAkNG9BM1AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldE9wZW4oZmFsc2UpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0T3BlblxuICAgIF0pO1xuICAgIGNvbnN0IHRvZ2dsZSA9ICgwLCAkNG9BM1AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldE9wZW4oIWlzT3Blbik7XG4gICAgfSwgW1xuICAgICAgICBzZXRPcGVuLFxuICAgICAgICBpc09wZW5cbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc09wZW46IGlzT3BlbixcbiAgICAgICAgc2V0T3Blbjogc2V0T3BlbixcbiAgICAgICAgb3Blbjogb3BlbixcbiAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICB0b2dnbGU6IHRvZ2dsZVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JGZjOTA5NzYyYjMzMGI3NDYkZXhwb3J0JDYxYzZhOGM4NGU2MDVmYjYgYXMgdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/radio/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/radio/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRadioGroupState: () => (/* binding */ $a54cdc5c1942b639$export$bca9d026f8e704eb)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nlet $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 10000000000);\nlet $a54cdc5c1942b639$var$i = 0;\nfunction $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {\n    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n    let name = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [\n        props.name\n    ]);\n    let [selectedValue, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, props.defaultValue, props.onChange);\n    let [lastFocusedValue, setLastFocusedValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let setSelectedValue = (value)=>{\n        if (!props.isReadOnly && !props.isDisabled) setSelected(value);\n    };\n    return {\n        name: name,\n        selectedValue: selectedValue,\n        setSelectedValue: setSelectedValue,\n        lastFocusedValue: lastFocusedValue,\n        setLastFocusedValue: setLastFocusedValue,\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isRequired: props.isRequired || false,\n        validationState: props.validationState || null,\n        isInvalid: props.isInvalid || props.validationState === \"invalid\"\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRjtBQUNSOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQWMsbUNBQW1DLCtCQUErQixHQUFHLDBCQUEwQjtBQUNoSTtBQUNBO0FBQ0EsMkNBQTJDLG9FQUF5QjtBQUNwRSxzREFBc0QsMkNBQWU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS3lFO0FBQ3pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWxmYS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9yYWRpby9kaXN0L2ltcG9ydC5tanM/MDViMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkZlEyU0YkdXNlTWVtbywgdXNlU3RhdGUgYXMgJGZRMlNGJHVzZVN0YXRlfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxubGV0ICRhNTRjZGM1YzE5NDJiNjM5JHZhciRpbnN0YW5jZSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcbmxldCAkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaSA9IDA7XG5mdW5jdGlvbiAkYTU0Y2RjNWMxOTQyYjYzOSRleHBvcnQkYmNhOWQwMjZmOGU3MDRlYihwcm9wcykge1xuICAgIC8vIFByZXNlcnZlZCBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBSZWFjdCBBcmlhIG5vdyBnZW5lcmF0ZXMgdGhlIG5hbWUgaW5zdGVhZCBvZiBzdGF0ZWx5LlxuICAgIGxldCBuYW1lID0gKDAsICRmUTJTRiR1c2VNZW1vKSgoKT0+cHJvcHMubmFtZSB8fCBgcmFkaW8tZ3JvdXAtJHskYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaW5zdGFuY2V9LSR7KyskYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaX1gLCBbXG4gICAgICAgIHByb3BzLm5hbWVcbiAgICBdKTtcbiAgICBsZXQgW3NlbGVjdGVkVmFsdWUsIHNldFNlbGVjdGVkXSA9ICgwLCAkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IFtsYXN0Rm9jdXNlZFZhbHVlLCBzZXRMYXN0Rm9jdXNlZFZhbHVlXSA9ICgwLCAkZlEyU0YkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBzZXRTZWxlY3RlZFZhbHVlID0gKHZhbHVlKT0+e1xuICAgICAgICBpZiAoIXByb3BzLmlzUmVhZE9ubHkgJiYgIXByb3BzLmlzRGlzYWJsZWQpIHNldFNlbGVjdGVkKHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgIHNldFNlbGVjdGVkVmFsdWU6IHNldFNlbGVjdGVkVmFsdWUsXG4gICAgICAgIGxhc3RGb2N1c2VkVmFsdWU6IGxhc3RGb2N1c2VkVmFsdWUsXG4gICAgICAgIHNldExhc3RGb2N1c2VkVmFsdWU6IHNldExhc3RGb2N1c2VkVmFsdWUsXG4gICAgICAgIGlzRGlzYWJsZWQ6IHByb3BzLmlzRGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVhZE9ubHk6IHByb3BzLmlzUmVhZE9ubHkgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVxdWlyZWQ6IHByb3BzLmlzUmVxdWlyZWQgfHwgZmFsc2UsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0ZTogcHJvcHMudmFsaWRhdGlvblN0YXRlIHx8IG51bGwsXG4gICAgICAgIGlzSW52YWxpZDogcHJvcHMuaXNJbnZhbGlkIHx8IHByb3BzLnZhbGlkYXRpb25TdGF0ZSA9PT0gXCJpbnZhbGlkXCJcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyRhNTRjZGM1YzE5NDJiNjM5JGV4cG9ydCRiY2E5ZDAyNmY4ZTcwNGViIGFzIHVzZVJhZGlvR3JvdXBTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/radio/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/selection/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-stately/selection/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionManager: () => (/* binding */ $d496c0a20b6e58ec$export$6c8a5aaad13c9852),\n/* harmony export */   useMultipleSelectionState: () => (/* binding */ $7af3f5b51489e0b5$export$253fe78d46329472)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n    constructor(keys, anchorKey, currentKey){\n        super(keys);\n        if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n            this.anchorKey = anchorKey || keys.anchorKey;\n            this.currentKey = currentKey || keys.currentKey;\n        } else {\n            this.anchorKey = anchorKey;\n            this.currentKey = currentKey;\n        }\n    }\n}\n\n\n\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let [, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let focusedKeyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let childFocusStrategyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let [, setFocusedKey] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let selectedKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectionBehaviorProp);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nclass $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n    /**\n   * The type of selection that is allowed in the collection.\n   */ get selectionMode() {\n        return this.state.selectionMode;\n    }\n    /**\n   * Whether the collection allows empty selection.\n   */ get disallowEmptySelection() {\n        return this.state.disallowEmptySelection;\n    }\n    /**\n   * The selection behavior for the collection.\n   */ get selectionBehavior() {\n        return this.state.selectionBehavior;\n    }\n    /**\n   * Sets the selection behavior for the collection.\n   */ setSelectionBehavior(selectionBehavior) {\n        this.state.setSelectionBehavior(selectionBehavior);\n    }\n    /**\n   * Whether the collection is currently focused.\n   */ get isFocused() {\n        return this.state.isFocused;\n    }\n    /**\n   * Sets whether the collection is focused.\n   */ setFocused(isFocused) {\n        this.state.setFocused(isFocused);\n    }\n    /**\n   * The current focused key in the collection.\n   */ get focusedKey() {\n        return this.state.focusedKey;\n    }\n    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {\n        return this.state.childFocusStrategy;\n    }\n    /**\n   * Sets the focused key.\n   */ setFocusedKey(key, childFocusStrategy) {\n        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n    /**\n   * The currently selected keys in the collection.\n   */ get selectedKeys() {\n        return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n    /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */ get rawSelection() {\n        return this.state.selectedKeys;\n    }\n    /**\n   * Returns whether a key is selected.\n   */ isSelected(key) {\n        if (this.state.selectionMode === \"none\") return false;\n        key = this.getKey(key);\n        return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n    /**\n   * Whether the selection is empty.\n   */ get isEmpty() {\n        return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n    }\n    /**\n   * Whether all items in the collection are selected.\n   */ get isSelectAll() {\n        if (this.isEmpty) return false;\n        if (this.state.selectedKeys === \"all\") return true;\n        if (this._isSelectAll != null) return this._isSelectAll;\n        let allKeys = this.getSelectAllKeys();\n        let selectedKeys = this.state.selectedKeys;\n        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));\n        return this._isSelectAll;\n    }\n    get firstSelectedKey() {\n        let first = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!first || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n        }\n        return first === null || first === void 0 ? void 0 : first.key;\n    }\n    get lastSelectedKey() {\n        let last = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!last || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n        }\n        return last === null || last === void 0 ? void 0 : last.key;\n    }\n    get disabledKeys() {\n        return this.state.disabledKeys;\n    }\n    get disabledBehavior() {\n        return this.state.disabledBehavior;\n    }\n    /**\n   * Extends the selection to the given key.\n   */ extendSelection(toKey) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            this.replaceSelection(toKey);\n            return;\n        }\n        toKey = this.getKey(toKey);\n        let selection;\n        // Only select the one key if coming from a select all.\n        if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            toKey\n        ], toKey, toKey);\n        else {\n            let selectedKeys = this.state.selectedKeys;\n            let anchorKey = selectedKeys.anchorKey || toKey;\n            selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);\n            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getKeyRange(from, to) {\n        let fromItem = this.collection.getItem(from);\n        let toItem = this.collection.getItem(to);\n        if (fromItem && toItem) {\n            if ((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n            return this.getKeyRangeInternal(to, from);\n        }\n        return [];\n    }\n    getKeyRangeInternal(from, to) {\n        let keys = [];\n        let key = from;\n        while(key){\n            let item = this.collection.getItem(key);\n            if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n            if (key === to) return keys;\n            key = this.collection.getKeyAfter(key);\n        }\n        return [];\n    }\n    getKey(key) {\n        let item = this.collection.getItem(key);\n        if (!item) // Â¯\\_(ãƒ„)_/Â¯\n        return key;\n        // If cell selection is allowed, just return the key.\n        if (item.type === \"cell\" && this.allowsCellSelection) return key;\n        // Find a parent item to select\n        while(item.type !== \"item\" && item.parentKey != null)item = this.collection.getItem(item.parentKey);\n        if (!item || item.type !== \"item\") return null;\n        return item.key;\n    }\n    /**\n   * Toggles whether the given key is selected.\n   */ toggleSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n            this.replaceSelection(key);\n            return;\n        }\n        key = this.getKey(key);\n        if (key == null) return;\n        let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n        if (keys.has(key)) keys.delete(key);\n        else if (this.canSelectItem(key)) {\n            keys.add(key);\n            keys.anchorKey = key;\n            keys.currentKey = key;\n        }\n        if (this.disallowEmptySelection && keys.size === 0) return;\n        this.state.setSelectedKeys(keys);\n    }\n    /**\n   * Replaces the selection with only the given key.\n   */ replaceSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        key = this.getKey(key);\n        if (key == null) return;\n        let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            key\n        ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        this.state.setSelectedKeys(selection);\n    }\n    /**\n   * Replaces the selection with the given keys.\n   */ setSelectedKeys(keys) {\n        if (this.selectionMode === \"none\") return;\n        let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        for (let key of keys){\n            key = this.getKey(key);\n            if (key != null) {\n                selection.add(key);\n                if (this.selectionMode === \"single\") break;\n            }\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getSelectAllKeys() {\n        let keys = [];\n        let addKeys = (key)=>{\n            while(key){\n                if (this.canSelectItem(key)) {\n                    let item = this.collection.getItem(key);\n                    if (item.type === \"item\") keys.push(key);\n                    // Add child keys. If cell selection is allowed, then include item children too.\n                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, this.collection)).key);\n                }\n                key = this.collection.getKeyAfter(key);\n            }\n        };\n        addKeys(this.collection.getFirstKey());\n        return keys;\n    }\n    /**\n   * Selects all items in the collection.\n   */ selectAll() {\n        if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n    }\n    /**\n   * Removes all keys from the selection.\n   */ clearSelection() {\n        if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n    }\n    /**\n   * Toggles between select all and an empty selection.\n   */ toggleSelectAll() {\n        if (this.isSelectAll) this.clearSelection();\n        else this.selectAll();\n    }\n    select(key, e) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);\n            else this.replaceSelection(key);\n        } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        this.toggleSelection(key);\n        else this.replaceSelection(key);\n    }\n    /**\n   * Returns whether the current selection is equal to the given selection.\n   */ isSelectionEqual(selection) {\n        if (selection === this.state.selectedKeys) return true;\n        // Check if the set of keys match.\n        let selectedKeys = this.selectedKeys;\n        if (selection.size !== selectedKeys.size) return false;\n        for (let key of selection){\n            if (!selectedKeys.has(key)) return false;\n        }\n        for (let key of selectedKeys){\n            if (!selection.has(key)) return false;\n        }\n        return true;\n    }\n    canSelectItem(key) {\n        if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n        let item = this.collection.getItem(key);\n        if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n        return true;\n    }\n    isDisabled(key) {\n        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n    }\n    isLink(key) {\n        var _this_collection_getItem, _this_collection_getItem_props;\n        return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n    constructor(collection, state, options){\n        this.collection = collection;\n        this.state = state;\n        var _options_allowsCellSelection;\n        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n        this._isSelectAll = null;\n    }\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxSTtBQUNoRDtBQUM4RTs7QUFFbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVQQUF1UDtBQUNqUTtBQUNBO0FBQ0EsMkJBQTJCLHlDQUFhO0FBQ3hDLDZCQUE2QiwyQ0FBZTtBQUM1Qyw0QkFBNEIseUNBQWE7QUFDekMsb0NBQW9DLHlDQUFhO0FBQ2pELGdDQUFnQywyQ0FBZTtBQUMvQywrQkFBK0IsMENBQWM7QUFDN0M7QUFDQTtBQUNBLGtDQUFrQywwQ0FBYztBQUNoRDtBQUNBO0FBQ0EsOENBQThDLG9FQUF5QjtBQUN2RSwrQkFBK0IsMENBQWM7QUFDN0M7QUFDQTtBQUNBLHdEQUF3RCwyQ0FBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBYTtBQUNqRCxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3RUFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0VBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3RUFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsb0VBQW1CLE1BQU0scUVBQW9CO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLK0k7QUFDL0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGZhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvbi9kaXN0L2ltcG9ydC5tanM/OWM2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVJlZiBhcyAkUXN0bzIkdXNlUmVmLCB1c2VTdGF0ZSBhcyAkUXN0bzIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJFFzdG8yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkUXN0bzIkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0IHtjb21wYXJlTm9kZU9yZGVyIGFzICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyLCBnZXRGaXJzdEl0ZW0gYXMgJFFzdG8yJGdldEZpcnN0SXRlbSwgZ2V0Q2hpbGROb2RlcyBhcyAkUXN0bzIkZ2V0Q2hpbGROb2Rlc30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYgZXh0ZW5kcyBTZXQge1xuICAgIGNvbnN0cnVjdG9yKGtleXMsIGFuY2hvcktleSwgY3VycmVudEtleSl7XG4gICAgICAgIHN1cGVyKGtleXMpO1xuICAgICAgICBpZiAoa2V5cyBpbnN0YW5jZW9mICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvcktleSA9IGFuY2hvcktleSB8fCBrZXlzLmFuY2hvcktleTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleSA9IGN1cnJlbnRLZXkgfHwga2V5cy5jdXJyZW50S2V5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbmNob3JLZXkgPSBhbmNob3JLZXk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRLZXkgPSBjdXJyZW50S2V5O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGVxdWFsU2V0cyhzZXRBLCBzZXRCKSB7XG4gICAgaWYgKHNldEEuc2l6ZSAhPT0gc2V0Qi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaXRlbSBvZiBzZXRBKXtcbiAgICAgICAgaWYgKCFzZXRCLmhhcyhpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICQ3YWYzZjViNTE0ODllMGI1JGV4cG9ydCQyNTNmZTc4ZDQ2MzI5NDcyKHByb3BzKSB7XG4gICAgbGV0IHsgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSA9IFwibm9uZVwiLCBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uOiBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uLCBhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50czogYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMsIHNlbGVjdGlvbkJlaGF2aW9yOiBzZWxlY3Rpb25CZWhhdmlvclByb3AgPSBcInRvZ2dsZVwiLCBkaXNhYmxlZEJlaGF2aW9yOiBkaXNhYmxlZEJlaGF2aW9yID0gXCJhbGxcIiB9ID0gcHJvcHM7XG4gICAgLy8gV2Ugd2FudCBzeW5jaHJvbm91cyB1cGRhdGVzIHRvIGBpc0ZvY3VzZWRgIGFuZCBgZm9jdXNlZEtleWAgYWZ0ZXIgdGhlaXIgc2V0dGVycyBhcmUgY2FsbGVkLlxuICAgIC8vIEJ1dCB3ZSBhbHNvIG5lZWQgdG8gdHJpZ2dlciBhIHJlYWN0IHJlLXJlbmRlci4gU28sIHdlIGhhdmUgYm90aCBhIHJlZiAoc3luYykgYW5kIHN0YXRlIChhc3luYykuXG4gICAgbGV0IGlzRm9jdXNlZFJlZiA9ICgwLCAkUXN0bzIkdXNlUmVmKShmYWxzZSk7XG4gICAgbGV0IFssIHNldEZvY3VzZWRdID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBmb2N1c2VkS2V5UmVmID0gKDAsICRRc3RvMiR1c2VSZWYpKG51bGwpO1xuICAgIGxldCBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikobnVsbCk7XG4gICAgbGV0IFssIHNldEZvY3VzZWRLZXldID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IHNlbGVjdGVkS2V5c1Byb3AgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT4kN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkY29udmVydFNlbGVjdGlvbihwcm9wcy5zZWxlY3RlZEtleXMpLCBbXG4gICAgICAgIHByb3BzLnNlbGVjdGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBkZWZhdWx0U2VsZWN0ZWRLZXlzID0gKDAsICRRc3RvMiR1c2VNZW1vKSgoKT0+JDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24ocHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5cywgbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKSksIFtcbiAgICAgICAgcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBbc2VsZWN0ZWRLZXlzLCBzZXRTZWxlY3RlZEtleXNdID0gKDAsICRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGUpKHNlbGVjdGVkS2V5c1Byb3AsIGRlZmF1bHRTZWxlY3RlZEtleXMsIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICBsZXQgZGlzYWJsZWRLZXlzUHJvcCA9ICgwLCAkUXN0bzIkdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgW3NlbGVjdGlvbkJlaGF2aW9yLCBzZXRTZWxlY3Rpb25CZWhhdmlvcl0gPSAoMCwgJFFzdG8yJHVzZVN0YXRlKShzZWxlY3Rpb25CZWhhdmlvclByb3ApO1xuICAgIC8vIElmIHRoZSBzZWxlY3Rpb25CZWhhdmlvciBwcm9wIGlzIHNldCB0byByZXBsYWNlLCBidXQgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdG9nZ2xlIChlLmcuIGR1ZSB0byBsb25nIHByZXNzXG4gICAgLy8gdG8gZW50ZXIgc2VsZWN0aW9uIG1vZGUgb24gdG91Y2gpLCBhbmQgdGhlIHNlbGVjdGlvbiBiZWNvbWVzIGVtcHR5LCByZXNldCB0aGUgc2VsZWN0aW9uIGJlaGF2aW9yLlxuICAgIGlmIChzZWxlY3Rpb25CZWhhdmlvclByb3AgPT09IFwicmVwbGFjZVwiICYmIHNlbGVjdGlvbkJlaGF2aW9yID09PSBcInRvZ2dsZVwiICYmIHR5cGVvZiBzZWxlY3RlZEtleXMgPT09IFwib2JqZWN0XCIgJiYgc2VsZWN0ZWRLZXlzLnNpemUgPT09IDApIHNldFNlbGVjdGlvbkJlaGF2aW9yKFwicmVwbGFjZVwiKTtcbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uQmVoYXZpb3IgcHJvcCBjaGFuZ2VzLCB1cGRhdGUgdGhlIHN0YXRlIGFzIHdlbGwuXG4gICAgbGV0IGxhc3RTZWxlY3Rpb25CZWhhdmlvciA9ICgwLCAkUXN0bzIkdXNlUmVmKShzZWxlY3Rpb25CZWhhdmlvclByb3ApO1xuICAgICgwLCAkUXN0bzIkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uQmVoYXZpb3JQcm9wICE9PSBsYXN0U2VsZWN0aW9uQmVoYXZpb3IuY3VycmVudCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uQmVoYXZpb3Ioc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25CZWhhdmlvci5jdXJyZW50ID0gc2VsZWN0aW9uQmVoYXZpb3JQcm9wO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBzZWxlY3Rpb25CZWhhdmlvclByb3BcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uOiBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25CZWhhdmlvcjogc2VsZWN0aW9uQmVoYXZpb3IsXG4gICAgICAgIHNldFNlbGVjdGlvbkJlaGF2aW9yOiBzZXRTZWxlY3Rpb25CZWhhdmlvcixcbiAgICAgICAgZ2V0IGlzRm9jdXNlZCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGb2N1c2VkUmVmLmN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEZvY3VzZWQgKGYpIHtcbiAgICAgICAgICAgIGlzRm9jdXNlZFJlZi5jdXJyZW50ID0gZjtcbiAgICAgICAgICAgIHNldEZvY3VzZWQoZik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBmb2N1c2VkS2V5ICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb2N1c2VkS2V5UmVmLmN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZEZvY3VzU3RyYXRlZ3kgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkRm9jdXNTdHJhdGVneVJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXRGb2N1c2VkS2V5IChrLCBjaGlsZEZvY3VzU3RyYXRlZ3kgPSBcImZpcnN0XCIpIHtcbiAgICAgICAgICAgIGZvY3VzZWRLZXlSZWYuY3VycmVudCA9IGs7XG4gICAgICAgICAgICBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYuY3VycmVudCA9IGNoaWxkRm9jdXNTdHJhdGVneTtcbiAgICAgICAgICAgIHNldEZvY3VzZWRLZXkoayk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzLFxuICAgICAgICBzZXRTZWxlY3RlZEtleXMgKGtleXMpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50cyB8fCAhJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGVxdWFsU2V0cyhrZXlzLCBzZWxlY3RlZEtleXMpKSBzZXRTZWxlY3RlZEtleXMoa2V5cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzUHJvcCxcbiAgICAgICAgZGlzYWJsZWRCZWhhdmlvcjogZGlzYWJsZWRCZWhhdmlvclxuICAgIH07XG59XG5mdW5jdGlvbiAkN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkY29udmVydFNlbGVjdGlvbihzZWxlY3Rpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghc2VsZWN0aW9uKSByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiBzZWxlY3Rpb24gPT09IFwiYWxsXCIgPyBcImFsbFwiIDogbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoc2VsZWN0aW9uKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNsYXNzICRkNDk2YzBhMjBiNmU1OGVjJGV4cG9ydCQ2YzhhNWFhYWQxM2M5ODUyIHtcbiAgICAvKipcbiAgICogVGhlIHR5cGUgb2Ygc2VsZWN0aW9uIHRoYXQgaXMgYWxsb3dlZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBzZWxlY3Rpb25Nb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3Rpb25Nb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICogV2hldGhlciB0aGUgY29sbGVjdGlvbiBhbGxvd3MgZW1wdHkgc2VsZWN0aW9uLlxuICAgKi8gZ2V0IGRpc2FsbG93RW1wdHlTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FsbG93RW1wdHlTZWxlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgc2VsZWN0aW9uIGJlaGF2aW9yIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBzZWxlY3Rpb25CZWhhdmlvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0aW9uQmVoYXZpb3I7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3Rpb24gYmVoYXZpb3IgZm9yIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gc2V0U2VsZWN0aW9uQmVoYXZpb3Ioc2VsZWN0aW9uQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3Rpb25CZWhhdmlvcihzZWxlY3Rpb25CZWhhdmlvcik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb2xsZWN0aW9uIGlzIGN1cnJlbnRseSBmb2N1c2VkLlxuICAgKi8gZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGb2N1c2VkO1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSBjb2xsZWN0aW9uIGlzIGZvY3VzZWQuXG4gICAqLyBzZXRGb2N1c2VkKGlzRm9jdXNlZCkge1xuICAgICAgICB0aGlzLnN0YXRlLnNldEZvY3VzZWQoaXNGb2N1c2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGZvY3VzZWQga2V5IGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gZ2V0IGZvY3VzZWRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZvY3VzZWRLZXk7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoZSBmaXJzdCBvciBsYXN0IGNoaWxkIG9mIHRoZSBmb2N1c2VkIGtleSBzaG91bGQgcmVjZWl2ZSBmb2N1cy4gKi8gZ2V0IGNoaWxkRm9jdXNTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY2hpbGRGb2N1c1N0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB0aGUgZm9jdXNlZCBrZXkuXG4gICAqLyBzZXRGb2N1c2VkS2V5KGtleSwgY2hpbGRGb2N1c1N0cmF0ZWd5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpKSB0aGlzLnN0YXRlLnNldEZvY3VzZWRLZXkoa2V5LCBjaGlsZEZvY3VzU3RyYXRlZ3kpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBrZXlzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gZ2V0IHNlbGVjdGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gbmV3IFNldCh0aGlzLmdldFNlbGVjdEFsbEtleXMoKSkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSByYXcgc2VsZWN0aW9uIHZhbHVlIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICogRWl0aGVyICdhbGwnIGZvciBzZWxlY3QgYWxsLCBvciBhIHNldCBvZiBrZXlzLlxuICAgKi8gZ2V0IHJhd1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEga2V5IGlzIHNlbGVjdGVkLlxuICAgKi8gaXNTZWxlY3RlZChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gdGhpcy5jYW5TZWxlY3RJdGVtKGtleSkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cy5oYXMoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eS5cbiAgICovIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgIT09IFwiYWxsXCIgJiYgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuc2l6ZSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIGFyZSBzZWxlY3RlZC5cbiAgICovIGdldCBpc1NlbGVjdEFsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RBbGwgIT0gbnVsbCkgcmV0dXJuIHRoaXMuX2lzU2VsZWN0QWxsO1xuICAgICAgICBsZXQgYWxsS2V5cyA9IHRoaXMuZ2V0U2VsZWN0QWxsS2V5cygpO1xuICAgICAgICBsZXQgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0QWxsID0gYWxsS2V5cy5ldmVyeSgoayk9PnNlbGVjdGVkS2V5cy5oYXMoaykpO1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RBbGw7XG4gICAgfVxuICAgIGdldCBmaXJzdFNlbGVjdGVkS2V5KCkge1xuICAgICAgICBsZXQgZmlyc3QgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpe1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdCB8fCBpdGVtICYmICgwLCAkUXN0bzIkY29tcGFyZU5vZGVPcmRlcikodGhpcy5jb2xsZWN0aW9uLCBpdGVtLCBmaXJzdCkgPCAwKSBmaXJzdCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBudWxsIHx8IGZpcnN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdC5rZXk7XG4gICAgfVxuICAgIGdldCBsYXN0U2VsZWN0ZWRLZXkoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBpdGVtICYmICgwLCAkUXN0bzIkY29tcGFyZU5vZGVPcmRlcikodGhpcy5jb2xsZWN0aW9uLCBpdGVtLCBsYXN0KSA+IDApIGxhc3QgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3Qua2V5O1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhYmxlZEtleXM7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZEJlaGF2aW9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhYmxlZEJlaGF2aW9yO1xuICAgIH1cbiAgICAvKipcbiAgICogRXh0ZW5kcyB0aGUgc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiBrZXkuXG4gICAqLyBleHRlbmRTZWxlY3Rpb24odG9LZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKHRvS2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0b0tleSA9IHRoaXMuZ2V0S2V5KHRvS2V5KTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbjtcbiAgICAgICAgLy8gT25seSBzZWxlY3QgdGhlIG9uZSBrZXkgaWYgY29taW5nIGZyb20gYSBzZWxlY3QgYWxsLlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIpIHNlbGVjdGlvbiA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKFtcbiAgICAgICAgICAgIHRvS2V5XG4gICAgICAgIF0sIHRvS2V5LCB0b0tleSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgICAgICAgICAgbGV0IGFuY2hvcktleSA9IHNlbGVjdGVkS2V5cy5hbmNob3JLZXkgfHwgdG9LZXk7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShzZWxlY3RlZEtleXMsIGFuY2hvcktleSwgdG9LZXkpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuZ2V0S2V5UmFuZ2UoYW5jaG9yS2V5LCBzZWxlY3RlZEtleXMuY3VycmVudEtleSB8fCB0b0tleSkpc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuZ2V0S2V5UmFuZ2UodG9LZXksIGFuY2hvcktleSkpaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSBzZWxlY3Rpb24uYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgZ2V0S2V5UmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGZyb21JdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oZnJvbSk7XG4gICAgICAgIGxldCB0b0l0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbSh0byk7XG4gICAgICAgIGlmIChmcm9tSXRlbSAmJiB0b0l0ZW0pIHtcbiAgICAgICAgICAgIGlmICgoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgZnJvbUl0ZW0sIHRvSXRlbSkgPD0gMCkgcmV0dXJuIHRoaXMuZ2V0S2V5UmFuZ2VJbnRlcm5hbChmcm9tLCB0byk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlSYW5nZUludGVybmFsKHRvLCBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldEtleVJhbmdlSW50ZXJuYWwoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcbiAgICAgICAgbGV0IGtleSA9IGZyb207XG4gICAgICAgIHdoaWxlKGtleSl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLnR5cGUgPT09IFwiaXRlbVwiIHx8IGl0ZW0udHlwZSA9PT0gXCJjZWxsXCIgJiYgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHRvKSByZXR1cm4ga2V5cztcbiAgICAgICAgICAgIGtleSA9IHRoaXMuY29sbGVjdGlvbi5nZXRLZXlBZnRlcihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0S2V5KGtleSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghaXRlbSkgLy8gwq9cXF8o44OEKV8vwq9cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgLy8gSWYgY2VsbCBzZWxlY3Rpb24gaXMgYWxsb3dlZCwganVzdCByZXR1cm4gdGhlIGtleS5cbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJjZWxsXCIgJiYgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uKSByZXR1cm4ga2V5O1xuICAgICAgICAvLyBGaW5kIGEgcGFyZW50IGl0ZW0gdG8gc2VsZWN0XG4gICAgICAgIHdoaWxlKGl0ZW0udHlwZSAhPT0gXCJpdGVtXCIgJiYgaXRlbS5wYXJlbnRLZXkgIT0gbnVsbClpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oaXRlbS5wYXJlbnRLZXkpO1xuICAgICAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlICE9PSBcIml0ZW1cIikgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBpdGVtLmtleTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRvZ2dsZXMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5IGlzIHNlbGVjdGVkLlxuICAgKi8gdG9nZ2xlU2VsZWN0aW9uKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiICYmICF0aGlzLmlzU2VsZWN0ZWQoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBrZXlzID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgPyB0aGlzLmdldFNlbGVjdEFsbEtleXMoKSA6IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIGtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAga2V5cy5hbmNob3JLZXkgPSBrZXk7XG4gICAgICAgICAgICBrZXlzLmN1cnJlbnRLZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiAmJiBrZXlzLnNpemUgPT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoa2V5cyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgZ2l2ZW4ga2V5LlxuICAgKi8gcmVwbGFjZVNlbGVjdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSA/IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKFtcbiAgICAgICAgICAgIGtleVxuICAgICAgICBdLCBrZXksIGtleSkgOiBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpO1xuICAgICAgICB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBrZXlzLlxuICAgKi8gc2V0U2VsZWN0ZWRLZXlzKGtleXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCk7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKXtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgZ2V0U2VsZWN0QWxsS2V5cygpIHtcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEtleXMgPSAoa2V5KT0+e1xuICAgICAgICAgICAgd2hpbGUoa2V5KXtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5TZWxlY3RJdGVtKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIml0ZW1cIikga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBjaGlsZCBrZXlzLiBJZiBjZWxsIHNlbGVjdGlvbiBpcyBhbGxvd2VkLCB0aGVuIGluY2x1ZGUgaXRlbSBjaGlsZHJlbiB0b28uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmhhc0NoaWxkTm9kZXMgJiYgKHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbiB8fCBpdGVtLnR5cGUgIT09IFwiaXRlbVwiKSkgYWRkS2V5cygoMCwgJFFzdG8yJGdldEZpcnN0SXRlbSkoKDAsICRRc3RvMiRnZXRDaGlsZE5vZGVzKShpdGVtLCB0aGlzLmNvbGxlY3Rpb24pKS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkS2V5cyh0aGlzLmNvbGxlY3Rpb24uZ2V0Rmlyc3RLZXkoKSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICogU2VsZWN0cyBhbGwgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBzZWxlY3RBbGwoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdEFsbCAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibXVsdGlwbGVcIikgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoXCJhbGxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXlzIGZyb20gdGhlIHNlbGVjdGlvbi5cbiAgICovIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiAmJiAodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuc2l6ZSA+IDApKSB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRvZ2dsZXMgYmV0d2VlbiBzZWxlY3QgYWxsIGFuZCBhbiBlbXB0eSBzZWxlY3Rpb24uXG4gICAqLyB0b2dnbGVTZWxlY3RBbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0QWxsKSB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIGVsc2UgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICB9XG4gICAgc2VsZWN0KGtleSwgZSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKGtleSkgJiYgIXRoaXMuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbikgdGhpcy50b2dnbGVTZWxlY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25CZWhhdmlvciA9PT0gXCJ0b2dnbGVcIiB8fCBlICYmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJ2aXJ0dWFsXCIpKSAvLyBpZiB0b3VjaCBvciB2aXJ0dWFsIChWTykgdGhlbiB3ZSBqdXN0IHdhbnQgdG8gdG9nZ2xlLCBvdGhlcndpc2UgaXQncyBpbXBvc3NpYmxlIHRvIG11bHRpIHNlbGVjdCBiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBtb2RpZmllciBrZXlzXG4gICAgICAgIHRoaXMudG9nZ2xlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgIGVsc2UgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBzZWxlY3Rpb24uXG4gICAqLyBpc1NlbGVjdGlvbkVxdWFsKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uID09PSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cykgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZXQgb2Yga2V5cyBtYXRjaC5cbiAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc2VsZWN0ZWRLZXlzO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLnNpemUgIT09IHNlbGVjdGVkS2V5cy5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBzZWxlY3Rpb24pe1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEtleXMuaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgb2Ygc2VsZWN0ZWRLZXlzKXtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhblNlbGVjdEl0ZW0oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiIHx8IHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtIHx8IGl0ZW0udHlwZSA9PT0gXCJjZWxsXCIgJiYgIXRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaXNEaXNhYmxlZChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzLmhhcyhrZXkpICYmIHRoaXMuc3RhdGUuZGlzYWJsZWRCZWhhdmlvciA9PT0gXCJhbGxcIjtcbiAgICB9XG4gICAgaXNMaW5rKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtLCBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHM7XG4gICAgICAgIHJldHVybiAhISgoX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSkgPT09IG51bGwgfHwgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzID0gX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcy5ocmVmKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbiwgc3RhdGUsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHZhciBfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24gPSAoX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbGxvd3NDZWxsU2VsZWN0aW9uKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uICE9PSB2b2lkIDAgPyBfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uIDogZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0QWxsID0gbnVsbDtcbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCB7JDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIgYXMgdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgJGQ0OTZjMGEyMGI2ZTU4ZWMkZXhwb3J0JDZjOGE1YWFhZDEzYzk4NTIgYXMgU2VsZWN0aW9uTWFuYWdlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/table/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/table/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex itemsâ€™ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the itemâ€™s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the itemâ€™s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\n     * Fix min/max violations. Clamp each non-frozen itemâ€™s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the itemâ€™s\n     * target main size was made smaller by this, itâ€™s a max\n     * violation. If the itemâ€™s target main size was made\n     * larger by this, itâ€™s a min violation.\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * âˆ‘(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\n\n\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        var _col_props_defaultWidth, _ref;\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this, _this_getDefaultWidth;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        return this.columnMinWidths.get(key);\n    }\n    getColumnMaxWidth(key) {\n        return this.columnMaxWidths.get(key);\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width, _column_props_width_endsWith;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\n\n\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)// eslint-disable-next-line max-depth\n                if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) {\n            if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n                if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) this.rowHeaderColumnKeys.add(this.columns[2].key);\n                else this.rowHeaderColumnKeys.add(this.columns[1].key);\n            } else this.rowHeaderColumnKeys.add(this.columns[0].key);\n        }\n    }\n}\n\n\n\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// Note: in order to reuse the render function of TableBody for our child rows, we just need to yield a type and a value here. CollectionBuilder will then look up\n                // the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n\n\n\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\nfunction $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n            child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else // We enforce that the cells come before rows so can just reuse cell index\n            visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQzFIO0FBQ2I7QUFDbEM7QUFDTTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFxRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLDBCQUEwQjtBQUM1RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxVQUFVLHVHQUF1RztBQUNqSCxrREFBa0QsMkNBQWU7QUFDakUsMkJBQTJCLDBDQUFjO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBDQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJDQUFlO0FBQ3pFO0FBQ0Esd0JBQXdCLDBDQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBa0I7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQWtCO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLDBDQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDREQUE0RCwrREFBcUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0VBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtRUFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsMkNBQWU7QUFDM0YsVUFBVSw0SEFBNEg7QUFDdEksc0JBQXNCLDBDQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUVBQW9CLGFBQWEsOENBQWtCO0FBQzVFO0FBQ0E7QUFDQSxVQUFVLGlFQUFpRSxNQUFNLDZEQUFtQjtBQUNwRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxZQUFZLGtDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQ0FBbUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0JBQW9CLGtDQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQStEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtDQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFGQUFxRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLDBIQUEwSCxjQUFjLFlBQVksd0JBQXdCO0FBQzVLO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBLFVBQVUsc1NBQXNTO0FBQ2hULGFBQWEsaUVBQXNCO0FBQ25DLDhDQUE4QyxvRUFBeUI7QUFDdkUsc0JBQXNCLDBDQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQWMsY0FBYyx5RUFBd0I7QUFDMUUsb0JBQW9CLDBDQUFjO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBDQUFjO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5Q0FBeUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUs0c0I7QUFDNXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWxmYS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90YWJsZS9kaXN0L2ltcG9ydC5tanM/M2ZiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NlY3Rpb24gYXMgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24sIHVzZUNvbGxlY3Rpb24gYXMgJDFCZmpXJHVzZUNvbGxlY3Rpb24sIGdldEZpcnN0SXRlbSBhcyAkMUJmalckZ2V0Rmlyc3RJdGVtLCBnZXRMYXN0SXRlbSBhcyAkMUJmalckZ2V0TGFzdEl0ZW0sIENvbGxlY3Rpb25CdWlsZGVyIGFzICQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQgJDFCZmpXJHJlYWN0LCB7dXNlU3RhdGUgYXMgJDFCZmpXJHVzZVN0YXRlLCB1c2VNZW1vIGFzICQxQmZqVyR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkMUJmalckdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VHcmlkU3RhdGUgYXMgJDFCZmpXJHVzZUdyaWRTdGF0ZSwgR3JpZENvbGxlY3Rpb24gYXMgJDFCZmpXJEdyaWRDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZ3JpZFwiO1xuaW1wb3J0IHt0YWJsZU5lc3RlZFJvd3MgYXMgJDFCZmpXJHRhYmxlTmVzdGVkUm93c30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2ZsYWdzXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkMUJmalckdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpIHtcbiAgICByZXR1cm4gd2lkdGggIT0gbnVsbCAmJiAoIWlzTmFOKHdpZHRoKSB8fCBTdHJpbmcod2lkdGgpLm1hdGNoKC9eKFxcZCspKD89JSQpLykgIT09IG51bGwpO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQod2lkdGgpIHtcbiAgICBpZiAoIXdpZHRoKSByZXR1cm4gMTtcbiAgICBsZXQgbWF0Y2ggPSB3aWR0aC5tYXRjaCgvXiguKykoPz1mciQpLyk7XG4gICAgLy8gaWYgd2lkdGggaXMgdGhlIGluY29ycmVjdCBmb3JtYXQsIGp1c3QgZGVmYXVsdCBpdCB0byBhIDFmclxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGB3aWR0aDogJHt3aWR0aH0gaXMgbm90IGEgc3VwcG9ydGVkIGZvcm1hdCwgd2lkdGggc2hvdWxkIGJlIGEgbnVtYmVyIChleC4gMTUwKSwgcGVyY2VudGFnZSAoZXguICc1MCUnKSBvciBmciB1bml0IChleC4gJzJmcicpYCwgXCJkZWZhdWx0aW5nIHRvICcxZnInXCIpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMF0pO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYod2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHdpZHRoLm1hdGNoKC9eKFxcZCspKD89JSQpLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgcGVyY2VudGFnZXMgb3IgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGZvciBzdGF0aWMgY29sdW1uIHdpZHRoc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhYmxlV2lkdGggKiAocGFyc2VGbG9hdChtYXRjaFswXSkgLyAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChtYXhXaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtYXhXaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWF4V2lkdGgsIHRhYmxlV2lkdGgpIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMShtaW5XaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtaW5XaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWluV2lkdGgsIHRhYmxlV2lkdGgpIDogMDtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKGF2YWlsYWJsZVdpZHRoLCBjb2x1bW5zLCBjaGFuZ2VkQ29sdW1ucywgZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGgpIHtcbiAgICBsZXQgaGFzTm9uRnJvemVuSXRlbXMgPSBmYWxzZTtcbiAgICBsZXQgZmxleEl0ZW1zID0gY29sdW1ucy5tYXAoKGNvbHVtbiwgaW5kZXgpPT57XG4gICAgICAgIHZhciBfY29sdW1uX3dpZHRoLCBfcmVmLCBfcmVmMTtcbiAgICAgICAgbGV0IHdpZHRoID0gY2hhbmdlZENvbHVtbnMuZ2V0KGNvbHVtbi5rZXkpICE9IG51bGwgPyBjaGFuZ2VkQ29sdW1ucy5nZXQoY29sdW1uLmtleSkgOiAoX3JlZjEgPSAoX3JlZiA9IChfY29sdW1uX3dpZHRoID0gY29sdW1uLndpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX3dpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX3dpZHRoIDogY29sdW1uLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGdldERlZmF1bHRXaWR0aCA9PT0gbnVsbCB8fCBnZXREZWZhdWx0V2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldERlZmF1bHRXaWR0aChpbmRleCkpICE9PSBudWxsICYmIF9yZWYxICE9PSB2b2lkIDAgPyBfcmVmMSA6IFwiMWZyXCI7XG4gICAgICAgIGxldCBmcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgbGV0IGJhc2VTaXplID0gMDtcbiAgICAgICAgbGV0IGZsZXggPSAwO1xuICAgICAgICBsZXQgdGFyZ2V0TWFpblNpemUgPSBudWxsO1xuICAgICAgICBpZiAoJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpKSB7XG4gICAgICAgICAgICBiYXNlU2l6ZSA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKHdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgICAgICBmcm96ZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxleCA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KHdpZHRoKTtcbiAgICAgICAgICAgIGlmIChmbGV4IDw9IDApIGZyb3plbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jb2x1bW5fbWluV2lkdGgsIF9yZWYyO1xuICAgICAgICBsZXQgbWluID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEoKF9yZWYyID0gKF9jb2x1bW5fbWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGgpICE9PSBudWxsICYmIF9jb2x1bW5fbWluV2lkdGggIT09IHZvaWQgMCA/IF9jb2x1bW5fbWluV2lkdGggOiBnZXREZWZhdWx0TWluV2lkdGggPT09IG51bGwgfHwgZ2V0RGVmYXVsdE1pbldpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXREZWZhdWx0TWluV2lkdGgoaW5kZXgpKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiAwLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGxldCBtYXggPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChjb2x1bW4ubWF4V2lkdGgsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgbGV0IGh5cG90aGV0aWNhbE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihiYXNlU2l6ZSwgbWF4KSk7XG4gICAgICAgIC8vIDkuNy4xXG4gICAgICAgIC8vIFdlIGRvbid0IG1ha2UgdXNlIG9mIGZsZXggYmFzaXMsIGl0J3MgYWx3YXlzIDAsIHNvIHdlIGFyZSBhbHdheXMgaW4gJ2dyb3cnIG1vZGUuXG4gICAgICAgIC8vIDkuNy4yXG4gICAgICAgIGlmIChmcm96ZW4pIHRhcmdldE1haW5TaXplID0gaHlwb3RoZXRpY2FsTWFpblNpemU7XG4gICAgICAgIGVsc2UgaWYgKGJhc2VTaXplID4gaHlwb3RoZXRpY2FsTWFpblNpemUpIHtcbiAgICAgICAgICAgIGZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICB0YXJnZXRNYWluU2l6ZSA9IGh5cG90aGV0aWNhbE1haW5TaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIDkuNy4zXG4gICAgICAgIGlmICghZnJvemVuKSBoYXNOb25Gcm96ZW5JdGVtcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm96ZW46IGZyb3plbixcbiAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSxcbiAgICAgICAgICAgIGh5cG90aGV0aWNhbE1haW5TaXplOiBoeXBvdGhldGljYWxNYWluU2l6ZSxcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICBmbGV4OiBmbGV4LFxuICAgICAgICAgICAgdGFyZ2V0TWFpblNpemU6IHRhcmdldE1haW5TaXplLFxuICAgICAgICAgICAgdmlvbGF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gOS43LjRcbiAgICAvLyA5LjcuNC5hXG4gICAgd2hpbGUoaGFzTm9uRnJvemVuSXRlbXMpe1xuICAgICAgICAvLyA5LjcuNC5iXG4gICAgICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UgYXMgZm9yIGluaXRpYWwgZnJlZSBzcGFjZSxcbiAgICAgKiBhYm92ZSAoOS43LjMpLiBJZiB0aGUgc3VtIG9mIHRoZSB1bmZyb3plbiBmbGV4IGl0ZW1z4oCZIGZsZXggZmFjdG9ycyBpc1xuICAgICAqIGxlc3MgdGhhbiBvbmUsIG11bHRpcGx5IHRoZSBpbml0aWFsIGZyZWUgc3BhY2UgYnkgdGhpcyBzdW0gKG9mIGZsZXggZmFjdG9ycykuXG4gICAgICogSWYgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWFnbml0dWRlIG9mXG4gICAgICogdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlLCB1c2UgdGhpcyBhcyB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UuXG4gICAgICovIGxldCB1c2VkV2lkdGggPSAwO1xuICAgICAgICBsZXQgZmxleEZhY3RvcnMgPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmIChpdGVtLmZyb3plbikgdXNlZFdpZHRoICs9IGl0ZW0udGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1c2VkV2lkdGggKz0gaXRlbS5iYXNlU2l6ZTtcbiAgICAgICAgICAgICAgICBmbGV4RmFjdG9ycyArPSBpdGVtLmZsZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVtYWluaW5nRnJlZVNwYWNlID0gYXZhaWxhYmxlV2lkdGggLSB1c2VkV2lkdGg7XG4gICAgICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBpbnRlZ2VyIEZSJ3MsIGFuZCBiZWNhdXNlIG9mIGhhc05vbkZyb3plbkl0ZW1zLCB3ZSBrbm93IHRoYXQgZmxleEZhY3RvcnMgPiAwXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGZsZXhGYWN0b3JzIDwgMVxuICAgICAgICAvLyA5LjcuNC5jXG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSBpcyB6ZXJvXG4gICAgICogLSBEbyBub3RoaW5nLlxuICAgICAqIEVsc2UgLy8gcmVtZW1iZXIsIHdlJ3JlIGFsd2F5cyBpbiBncm93IG1vZGVcbiAgICAgKiAtIEZpbmQgdGhlIHJhdGlvIG9mIHRoZSBpdGVt4oCZcyBmbGV4IGdyb3cgZmFjdG9yIHRvIHRoZVxuICAgICAqIHN1bSBvZiB0aGUgZmxleCBncm93IGZhY3RvcnMgb2YgYWxsIHVuZnJvemVuIGl0ZW1zIG9uXG4gICAgICogdGhlIGxpbmUuIFNldCB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB0byBpdHMgZmxleFxuICAgICAqIGJhc2Ugc2l6ZSBwbHVzIGEgZnJhY3Rpb24gb2YgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlXG4gICAgICogcHJvcG9ydGlvbmFsIHRvIHRoZSByYXRpby5cbiAgICAgKi8gaWYgKHJlbWFpbmluZ0ZyZWVTcGFjZSA+IDApIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xuICAgICAgICAgICAgaWYgKCFpdGVtLmZyb3plbikge1xuICAgICAgICAgICAgICAgIGxldCByYXRpbyA9IGl0ZW0uZmxleCAvIGZsZXhGYWN0b3JzO1xuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0TWFpblNpemUgPSBpdGVtLmJhc2VTaXplICsgcmF0aW8gKiByZW1haW5pbmdGcmVlU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5kXG4gICAgICAgIC8qKlxuICAgICAqIEZpeCBtaW4vbWF4IHZpb2xhdGlvbnMuIENsYW1wIGVhY2ggbm9uLWZyb3plbiBpdGVt4oCZc1xuICAgICAqIHRhcmdldCBtYWluIHNpemUgYnkgaXRzIHVzZWQgbWluIGFuZCBtYXggbWFpbiBzaXplc1xuICAgICAqIGFuZCBmbG9vciBpdHMgY29udGVudC1ib3ggc2l6ZSBhdCB6ZXJvLiBJZiB0aGUgaXRlbeKAmXNcbiAgICAgKiB0YXJnZXQgbWFpbiBzaXplIHdhcyBtYWRlIHNtYWxsZXIgYnkgdGhpcywgaXTigJlzIGEgbWF4XG4gICAgICogdmlvbGF0aW9uLiBJZiB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB3YXMgbWFkZVxuICAgICAqIGxhcmdlciBieSB0aGlzLCBpdOKAmXMgYSBtaW4gdmlvbGF0aW9uLlxuICAgICAqLyBsZXQgdG90YWxWaW9sYXRpb24gPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGl0ZW0udmlvbGF0aW9uID0gMDtcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHRhcmdldE1haW5TaXplOiB0YXJnZXRNYWluU2l6ZSB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbih0YXJnZXRNYWluU2l6ZSwgbWF4KSk7XG4gICAgICAgICAgICAgICAgaXRlbS52aW9sYXRpb24gPSBpdGVtLnRhcmdldE1haW5TaXplIC0gdGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICAgICAgdG90YWxWaW9sYXRpb24gKz0gaXRlbS52aW9sYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5lXG4gICAgICAgIC8qKlxuICAgICAqIEZyZWV6ZSBvdmVyLWZsZXhlZCBpdGVtcy4gVGhlIHRvdGFsIHZpb2xhdGlvbiBpcyB0aGVcbiAgICAgKiBzdW0gb2YgdGhlIGFkanVzdG1lbnRzIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgKiDiiJEoY2xhbXBlZCBzaXplIC0gdW5jbGFtcGVkIHNpemUpLiBJZiB0aGUgdG90YWwgdmlvbGF0aW9uIGlzOlxuICAgICAqIFplcm9cbiAgICAgKiAtIEZyZWV6ZSBhbGwgaXRlbXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZVxuICAgICAqIC0gRnJlZXplIGFsbCB0aGUgaXRlbXMgd2l0aCBtaW4gdmlvbGF0aW9ucy5cbiAgICAgKlxuICAgICAqIE5lZ2F0aXZlXG4gICAgICogLSBGcmVlemUgYWxsIHRoZSBpdGVtcyB3aXRoIG1heCB2aW9sYXRpb25zLlxuICAgICAqLyBoYXNOb25Gcm96ZW5JdGVtcyA9IGZhbHNlO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmICh0b3RhbFZpb2xhdGlvbiA9PT0gMCB8fCBNYXRoLnNpZ24odG90YWxWaW9sYXRpb24pID09PSBNYXRoLnNpZ24oaXRlbS52aW9sYXRpb24pKSBpdGVtLmZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICghaXRlbS5mcm96ZW4pIGhhc05vbkZyb3plbkl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcyk7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcykge1xuICAgIC8qXG4gIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cyB0aGF0IHN1bSB0byBhbiBpbnRlZ2VyLCB0aGlzIHJvdW5kcyB0aGUgZmxvYXRzXG4gIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGludGVnZXJzIHdpdGggdGhlIHNhbWUgc3VtLlxuICAqLyBsZXQgZnBUb3RhbCA9IDA7XG4gICAgbGV0IGludFRvdGFsID0gMDtcbiAgICBsZXQgcm91bmRlZEFycmF5ID0gW107XG4gICAgZmxleEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBsZXQgZmxvYXQgPSBpdGVtLnRhcmdldE1haW5TaXplO1xuICAgICAgICBsZXQgaW50ZWdlciA9IE1hdGgucm91bmQoZmxvYXQgKyBmcFRvdGFsKSAtIGludFRvdGFsO1xuICAgICAgICBmcFRvdGFsICs9IGZsb2F0O1xuICAgICAgICBpbnRUb3RhbCArPSBpbnRlZ2VyO1xuICAgICAgICByb3VuZGVkQXJyYXkucHVzaChpbnRlZ2VyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcm91bmRlZEFycmF5O1xufVxuXG5cbmNsYXNzICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIHtcbiAgICAvKiogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgc3BsaXRzIGl0IGludG8gMiBtYXBzIG9mIGNvbHVtbnMgd2l0aCBjb250cm9sbGVkIGFuZCBjb2x1bW5zIHdpdGggdW5jb250cm9sbGVkIHdpZHRocy4gKi8gc3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQoY29sdW1ucykge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKT0+e1xuICAgICAgICAgICAgaWYgKGNvbC5wcm9wcy53aWR0aCAhPSBudWxsKSBhY2NbMF0uc2V0KGNvbC5rZXksIGNvbCk7XG4gICAgICAgICAgICBlbHNlIGFjY1sxXS5zZXQoY29sLmtleSwgY29sKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG5ldyBNYXAoKSxcbiAgICAgICAgICAgIG5ldyBNYXAoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqIFRha2VzIHVuY29udHJvbGxlZCBhbmQgY29udHJvbGxlZCB3aWR0aHMgYW5kIGpvaW5zIHRoZW0gaW50byBhIHNpbmdsZSBNYXAuICovIHJlY29tYmluZUNvbHVtbnMoY29sdW1ucywgdW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChjb2x1bW5zLm1hcCgoY29sKT0+e1xuICAgICAgICAgICAgaWYgKHVuY29udHJvbGxlZENvbHVtbnMuaGFzKGNvbC5rZXkpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbC5rZXksXG4gICAgICAgICAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzLmdldChjb2wua2V5KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb2wua2V5LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLmdldChjb2wua2V5KS5wcm9wcy53aWR0aFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiogVXNlZCB0byBtYWtlIGFuIGluaXRpYWwgTWFwIG9mIHRoZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGJhc2VkIG9uIGRlZmF1bHQgd2lkdGhzLiAqLyBnZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpIHtcbiAgICAgICAgdmFyIF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoLCBfcmVmO1xuICAgICAgICByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKHVuY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleSwgY29sXSk9PntcbiAgICAgICAgICAgIHZhciBfdGhpcywgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgKF9yZWYgPSAoX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggPSBjb2wucHJvcHMuZGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCAhPT0gdm9pZCAwID8gX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggOiAoX3RoaXNfZ2V0RGVmYXVsdFdpZHRoID0gKF90aGlzID0gdGhpcykuZ2V0RGVmYXVsdFdpZHRoKSA9PT0gbnVsbCB8fCBfdGhpc19nZXREZWZhdWx0V2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2dldERlZmF1bHRXaWR0aC5jYWxsKF90aGlzLCBjb2wpKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogXCIxZnJcIlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXRDb2x1bW5XaWR0aChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbHVtbldpZHRoc19nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfY29sdW1uV2lkdGhzX2dldCA9IHRoaXMuY29sdW1uV2lkdGhzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0ICE9PSB2b2lkIDAgPyBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0IDogMDtcbiAgICB9XG4gICAgZ2V0Q29sdW1uTWluV2lkdGgoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbk1pbldpZHRocy5nZXQoa2V5KTtcbiAgICB9XG4gICAgZ2V0Q29sdW1uTWF4V2lkdGgoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbk1heFdpZHRocy5nZXQoa2V5KTtcbiAgICB9XG4gICAgcmVzaXplQ29sdW1uV2lkdGgodGFibGVXaWR0aCwgY29sbGVjdGlvbiwgY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkV2lkdGhzLCBjb2wgPSBudWxsLCB3aWR0aCkge1xuICAgICAgICBsZXQgcHJldkNvbHVtbldpZHRocyA9IHRoaXMuY29sdW1uV2lkdGhzO1xuICAgICAgICAvLyByZXNpemluZyBhIGNvbHVtblxuICAgICAgICBsZXQgcmVzaXplSW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IHJlc2l6aW5nQ2hhbmdlZCA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgLi4uY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgICAgIC4uLnVuY29udHJvbGxlZFdpZHRoc1xuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHBlcmNlbnRLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgZnJLZXlzVG9UaGVSaWdodCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IG1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gZnJlZXplIGNvbHVtbnMgdG8gdGhlIGxlZnQgdG8gdGhlaXIgcHJldmlvdXMgcGl4ZWwgdmFsdWVcbiAgICAgICAgY29sbGVjdGlvbi5jb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaSk9PntcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX3dpZHRoLCBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoO1xuICAgICAgICAgICAgbGV0IGZyS2V5O1xuICAgICAgICAgICAgbGV0IGZyVmFsdWU7XG4gICAgICAgICAgICBtaW5XaWR0aHMuc2V0KGNvbHVtbi5rZXksIHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAgICAgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAhY29sdW1uLnByb3BzLndpZHRoICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5jb250cm9sbGVkIGRvbid0IGhhdmUgcHJvcHMud2lkdGggZm9yIHVzLCBzbyBpbnN0ZWFkIGdldCBmcm9tIG91ciBzdGF0ZVxuICAgICAgICAgICAgICAgIGZyS2V5ID0gY29sdW1uLmtleTtcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KSh1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKGNvbHVtbi5wcm9wcy53aWR0aCkgJiYgIXVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250cm9sbGVkV2lkdGhzIHdpbGwgYmUgdGhlIHNhbWUgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBmcktleSA9IGNvbHVtbi5rZXk7XG4gICAgICAgICAgICAgICAgZnJWYWx1ZSA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCkoY29sdW1uLnByb3BzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICgoX2NvbHVtbl9wcm9wc193aWR0aCA9IGNvbHVtbi5wcm9wcy53aWR0aCkgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wc193aWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGggPSBfY29sdW1uX3Byb3BzX3dpZHRoLmVuZHNXaXRoKSA9PT0gbnVsbCB8fCBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoLmNhbGwoX2NvbHVtbl9wcm9wc193aWR0aCwgXCIlXCIpKSkgcGVyY2VudEtleXMuc2V0KGNvbHVtbi5rZXksIGNvbHVtbi5wcm9wcy53aWR0aCk7XG4gICAgICAgICAgICAvLyBkb24ndCBmcmVlemUgY29sdW1ucyB0byB0aGUgcmlnaHQgb2YgdGhlIHJlc2l6aW5nIG9uZVxuICAgICAgICAgICAgaWYgKHJlc2l6ZUluZGV4IDwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChmcktleSkgZnJLZXlzVG9UaGVSaWdodC5zZXQoZnJLZXksIGZyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGFscmVhZHkga25vdyB0aGUgbmV3IHNpemUgb2YgdGhlIHJlc2l6aW5nIGNvbHVtblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5rZXkgPT09IGNvbCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIE1hdGguZmxvb3Iod2lkdGgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmcmVlemUgY29sdW1uIHRvIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIHByZXZDb2x1bW5XaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByZWRpY3QgcGl4ZWxzIHNpemVzIGZvciBhbGwgY29sdW1ucyBiYXNlZCBvbiByZXNpemVcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSkodGFibGVXaWR0aCwgY29sbGVjdGlvbi5jb2x1bW5zLm1hcCgoY29sKT0+KHtcbiAgICAgICAgICAgICAgICAuLi5jb2wucHJvcHMsXG4gICAgICAgICAgICAgICAga2V5OiBjb2wua2V5XG4gICAgICAgICAgICB9KSksIHJlc2l6aW5nQ2hhbmdlZCwgKGkpPT50aGlzLmdldERlZmF1bHRXaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAvLyBzZXQgYWxsIG5ldyBjb2x1bW4gd2lkdGhzIGZvciBvblJlc2l6ZSBldmVudFxuICAgICAgICAvLyBjb2x1bW5zIGdvaW5nIGluIHdpbGwgYmUgdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNvbHVtbnMgY29taW5nIG91dFxuICAgICAgICBsZXQgbmV3V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBzZXQgYWxsIGNvbHVtbiB3aWR0aHMgYmFzZWQgb24gY2FsY3VsYXRlQ29sdW1uU2l6ZVxuICAgICAgICBjb2x1bW5XaWR0aHMuZm9yRWFjaCgod2lkdGgsIGluZGV4KT0+e1xuICAgICAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF0ua2V5O1xuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCBGUidzIGJhY2sgYXMgdGhleSB3ZXJlIHRvIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAgICAgIEFycmF5LmZyb20oZnJLZXlzVG9UaGVSaWdodCkuZm9yRWFjaCgoW2tleV0pPT57XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgYCR7ZnJLZXlzVG9UaGVSaWdodC5nZXQoa2V5KX1mcmApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHV0IGJhY2sgaW4gcGVyY2VudHNcbiAgICAgICAgQXJyYXkuZnJvbShwZXJjZW50S2V5cykuZm9yRWFjaCgoW2tleSwgd2lkdGhdKT0+e1xuICAgICAgICAgICAgLy8gcmVzaXppbmcgbG9ja3MgYSBjb2x1bW4gdG8gYSBweCB3aWR0aFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gY29sKSByZXR1cm47XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1dpZHRocztcbiAgICB9XG4gICAgYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgY29sbGVjdGlvbiwgd2lkdGhzKSB7XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGluaXRpYWwgbGF5b3V0IG9yIHRhYmxlL3dpbmRvdyByZXNpemluZ1xuICAgICAgICBsZXQgY29sdW1uV2lkdGhzID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKSh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLmNvbHVtbnMubWFwKChjb2wpPT4oe1xuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcbiAgICAgICAgICAgICAgICBrZXk6IGNvbC5rZXlcbiAgICAgICAgICAgIH0pKSwgd2lkdGhzLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdFdpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSksIChpKT0+dGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgIC8vIGNvbHVtbnMgZ29pbmcgaW4gd2lsbCBiZSB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1ucyBjb21pbmcgb3V0XG4gICAgICAgIGNvbHVtbldpZHRocy5mb3JFYWNoKCh3aWR0aCwgaW5kZXgpPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XS5rZXk7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uV2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX21pbldpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKSgoX2NvbHVtbl9wcm9wc19taW5XaWR0aCA9IGNvbHVtbi5wcm9wcy5taW5XaWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl9wcm9wc19taW5XaWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl9wcm9wc19taW5XaWR0aCA6IHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbHVtbiksIHRhYmxlV2lkdGgpKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzLnNldChrZXksICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMCkoY29sdW1uLnByb3BzLm1heFdpZHRoLCB0YWJsZVdpZHRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5XaWR0aHM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRXaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCA6ICgpPT5cIjFmclwiO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRNaW5XaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdE1pbldpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCA6ICgpPT43NTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gJDI5MmJjNGUwOWNkMGViNjIkZXhwb3J0JGNiODk1ZGNmODVkYjEzMTkocHJvcHMsIHN0YXRlKSB7XG4gICAgbGV0IHsgZ2V0RGVmYXVsdFdpZHRoOiBnZXREZWZhdWx0V2lkdGgsIGdldERlZmF1bHRNaW5XaWR0aDogZ2V0RGVmYXVsdE1pbldpZHRoLCB0YWJsZVdpZHRoOiB0YWJsZVdpZHRoID0gMCB9ID0gcHJvcHM7XG4gICAgbGV0IFtyZXNpemluZ0NvbHVtbiwgc2V0UmVzaXppbmdDb2x1bW5dID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IGNvbHVtbkxheW91dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGE5ZTdhZTU0NGE0ZTQxZGQkZXhwb3J0JDdmZjc3YTE2Mjk3MGIzMGUpKHtcbiAgICAgICAgICAgIGdldERlZmF1bHRXaWR0aDogZ2V0RGVmYXVsdFdpZHRoLFxuICAgICAgICAgICAgZ2V0RGVmYXVsdE1pbldpZHRoOiBnZXREZWZhdWx0TWluV2lkdGhcbiAgICAgICAgfSksIFtcbiAgICAgICAgZ2V0RGVmYXVsdFdpZHRoLFxuICAgICAgICBnZXREZWZhdWx0TWluV2lkdGhcbiAgICBdKTtcbiAgICBsZXQgW2NvbnRyb2xsZWRDb2x1bW5zLCB1bmNvbnRyb2xsZWRDb2x1bW5zXSA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmNvbHVtbkxheW91dC5zcGxpdENvbHVtbnNJbnRvQ29udHJvbGxlZEFuZFVuY29udHJvbGxlZChzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMpLCBbXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyxcbiAgICAgICAgY29sdW1uTGF5b3V0XG4gICAgXSk7XG4gICAgLy8gdW5jb250cm9sbGVkIGNvbHVtbiB3aWR0aHNcbiAgICBsZXQgW3VuY29udHJvbGxlZFdpZHRocywgc2V0VW5jb250cm9sbGVkV2lkdGhzXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKCgpPT5jb2x1bW5MYXlvdXQuZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyh1bmNvbnRyb2xsZWRDb2x1bW5zKSk7XG4gICAgLy8gY29tYmluZSBjb2x1bW5zIGJhY2sgaW50byBvbmUgbWFwIHRoYXQgbWFpbnRhaW5zIHNhbWUgb3JkZXIgYXMgdGhlIGNvbHVtbnNcbiAgICBsZXQgY29sV2lkdGhzID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LnJlY29tYmluZUNvbHVtbnMoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLCB1bmNvbnRyb2xsZWRXaWR0aHMsIHVuY29udHJvbGxlZENvbHVtbnMsIGNvbnRyb2xsZWRDb2x1bW5zKSwgW1xuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMsXG4gICAgICAgIHVuY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgdW5jb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIGNvbHVtbkxheW91dFxuICAgIF0pO1xuICAgIGxldCBzdGFydFJlc2l6ZSA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChrZXkpPT57XG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uKGtleSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtblxuICAgIF0pO1xuICAgIGxldCB1cGRhdGVSZXNpemVkQ29sdW1ucyA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChrZXksIHdpZHRoKT0+e1xuICAgICAgICBsZXQgbmV3Q29udHJvbGxlZCA9IG5ldyBNYXAoQXJyYXkuZnJvbShjb250cm9sbGVkQ29sdW1ucykubWFwKChba2V5LCBlbnRyeV0pPT5bXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGVudHJ5LnByb3BzLndpZHRoXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIGxldCBuZXdTaXplcyA9IGNvbHVtbkxheW91dC5yZXNpemVDb2x1bW5XaWR0aCh0YWJsZVdpZHRoLCBzdGF0ZS5jb2xsZWN0aW9uLCBuZXdDb250cm9sbGVkLCB1bmNvbnRyb2xsZWRXaWR0aHMsIGtleSwgd2lkdGgpO1xuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcChBcnJheS5mcm9tKHVuY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleV0pPT5bXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG5ld1NpemVzLmdldChrZXkpXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB3aWR0aCk7XG4gICAgICAgIHNldFVuY29udHJvbGxlZFdpZHRocyhtYXApO1xuICAgICAgICByZXR1cm4gbmV3U2l6ZXM7XG4gICAgfSwgW1xuICAgICAgICBjb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgdW5jb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgc2V0VW5jb250cm9sbGVkV2lkdGhzLFxuICAgICAgICB0YWJsZVdpZHRoLFxuICAgICAgICBjb2x1bW5MYXlvdXQsXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24sXG4gICAgICAgIHVuY29udHJvbGxlZFdpZHRoc1xuICAgIF0pO1xuICAgIGxldCBlbmRSZXNpemUgPSAoMCwgJDFCZmpXJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtbihudWxsKTtcbiAgICB9LCBbXG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uXG4gICAgXSk7XG4gICAgKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LmJ1aWxkQ29sdW1uV2lkdGhzKHRhYmxlV2lkdGgsIHN0YXRlLmNvbGxlY3Rpb24sIGNvbFdpZHRocyksIFtcbiAgICAgICAgdGFibGVXaWR0aCxcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbixcbiAgICAgICAgY29sV2lkdGhzLFxuICAgICAgICBjb2x1bW5MYXlvdXRcbiAgICBdKTtcbiAgICByZXR1cm4gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHJlc2l6aW5nQ29sdW1uOiByZXNpemluZ0NvbHVtbixcbiAgICAgICAgICAgIHVwZGF0ZVJlc2l6ZWRDb2x1bW5zOiB1cGRhdGVSZXNpemVkQ29sdW1ucyxcbiAgICAgICAgICAgIHN0YXJ0UmVzaXplOiBzdGFydFJlc2l6ZSxcbiAgICAgICAgICAgIGVuZFJlc2l6ZTogZW5kUmVzaXplLFxuICAgICAgICAgICAgZ2V0Q29sdW1uV2lkdGg6IChrZXkpPT5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uV2lkdGgoa2V5KSxcbiAgICAgICAgICAgIGdldENvbHVtbk1pbldpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbk1pbldpZHRoKGtleSksXG4gICAgICAgICAgICBnZXRDb2x1bW5NYXhXaWR0aDogKGtleSk9PmNvbHVtbkxheW91dC5nZXRDb2x1bW5NYXhXaWR0aChrZXkpLFxuICAgICAgICAgICAgdGFibGVTdGF0ZTogc3RhdGVcbiAgICAgICAgfSksIFtcbiAgICAgICAgY29sdW1uTGF5b3V0LFxuICAgICAgICByZXNpemluZ0NvbHVtbixcbiAgICAgICAgdXBkYXRlUmVzaXplZENvbHVtbnMsXG4gICAgICAgIHN0YXJ0UmVzaXplLFxuICAgICAgICBlbmRSZXNpemUsXG4gICAgICAgIHN0YXRlXG4gICAgXSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVkgPSBcInJvdy1oZWFkZXItY29sdW1uLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5sZXQgJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xud2hpbGUoJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSA9PT0gJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHKSQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyA9IFwicm93LWhlYWRlci1jb2x1bW4tXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlKGtleU1hcCwgY29sdW1uTm9kZXMpIHtcbiAgICBpZiAoY29sdW1uTm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1uTm9kZXMpe1xuICAgICAgICBsZXQgcGFyZW50S2V5ID0gY29sdW1uLnBhcmVudEtleTtcbiAgICAgICAgbGV0IGNvbCA9IFtcbiAgICAgICAgICAgIGNvbHVtblxuICAgICAgICBdO1xuICAgICAgICB3aGlsZShwYXJlbnRLZXkpe1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGtleU1hcC5nZXQocGFyZW50S2V5KTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KSBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgc2VlbiB0aGlzIHBhcmVudCwgdGhhbiBpdCBpcyBzaGFyZWRcbiAgICAgICAgICAgIC8vIHdpdGggYSBwcmV2aW91cyBjb2x1bW4uIElmIHRoZSBjdXJyZW50IGNvbHVtbiBpcyB0YWxsZXJcbiAgICAgICAgICAgIC8vIHRoYW4gdGhlIHByZXZpb3VzIGNvbHVtbiwgdGhhbiB3ZSBuZWVkIHRvIHNoaWZ0IHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGluIHRoZSBwcmV2aW91cyBjb2x1bW4gc28gaXQncyBsZXZlbCB3aXRoIHRoZSBjdXJyZW50IGNvbHVtbi5cbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbHNwYW4rKztcbiAgICAgICAgICAgICAgICBsZXQgeyBjb2x1bW46IGNvbHVtbiwgaW5kZXg6IGluZGV4IH0gPSBzZWVuLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IGNvbC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGluZGV4OyBpIDwgY29sLmxlbmd0aDsgaSsrKWNvbHVtbi5zcGxpY2UoaSwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHNoaWZ0ZWQgaW5kaWNlc1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IGNvbC5sZW5ndGg7IGkgPCBjb2x1bW4ubGVuZ3RoOyBpKyspLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5baV0gJiYgc2Vlbi5oYXMoY29sdW1uW2ldKSkgc2Vlbi5nZXQoY29sdW1uW2ldKS5pbmRleCA9IGk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5jb2xzcGFuID0gMTtcbiAgICAgICAgICAgICAgICBjb2wucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHNlZW4uc2V0KHBhcmVudCwge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNvbC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRLZXkgPSBwYXJlbnQucGFyZW50S2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICBjb2x1bW4uaW5kZXggPSBjb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGxldCBtYXhMZW5ndGggPSBNYXRoLm1heCguLi5jb2x1bW5zLm1hcCgoYyk9PmMubGVuZ3RoKSk7XG4gICAgbGV0IGhlYWRlclJvd3MgPSBBcnJheShtYXhMZW5ndGgpLmZpbGwoMCkubWFwKCgpPT5bXSk7XG4gICAgLy8gQ29udmVydCBjb2x1bW5zIGludG8gcm93cy5cbiAgICBsZXQgY29sSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2x1bW5zKXtcbiAgICAgICAgbGV0IGkgPSBtYXhMZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGNvbHVtbil7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIHNwYWNlIHVwIHVudGlsIHRoZSBjdXJyZW50IGNvbHVtbiB3aXRoIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gaGVhZGVyUm93c1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgcm93TGVuZ3RoID0gcm93LnJlZHVjZSgocCwgYyk9PnAgKyBjLmNvbHNwYW4sIDApO1xuICAgICAgICAgICAgICAgIGlmIChyb3dMZW5ndGggPCBjb2xJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwicGxhY2Vob2xkZXItXCIgKyBpdGVtLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNwYW46IGNvbEluZGV4IC0gcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgICAgICBpZiAocm93Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0ubmV4dEtleSA9IHBsYWNlaG9sZGVyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLnByZXZLZXkgPSByb3dbcm93Lmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByb3dbcm93Lmxlbmd0aCAtIDFdLm5leHRLZXkgPSBpdGVtLmtleTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmV2S2V5ID0gcm93W3Jvdy5sZW5ndGggLSAxXS5rZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0ubGV2ZWwgPSBpO1xuICAgICAgICAgICAgICAgIGl0ZW0uY29sSW5kZXggPSBjb2xJbmRleDtcbiAgICAgICAgICAgICAgICByb3cucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBjb2xJbmRleCsrO1xuICAgIH1cbiAgICAvLyBBZGQgcGxhY2Vob2xkZXJzIGF0IHRoZSBlbmQgb2YgZWFjaCByb3cgdGhhdCBpcyBzaG9ydGVyIHRoYW4gdGhlIG1heGltdW1cbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgcm93IG9mIGhlYWRlclJvd3Mpe1xuICAgICAgICBsZXQgcm93TGVuZ3RoID0gcm93LnJlZHVjZSgocCwgYyk9PnAgKyBjLmNvbHNwYW4sIDApO1xuICAgICAgICBpZiAocm93TGVuZ3RoIDwgY29sdW1uTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJwbGFjZWhvbGRlci1cIiArIHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5LFxuICAgICAgICAgICAgICAgIGNvbHNwYW46IGNvbHVtbk5vZGVzLmxlbmd0aCAtIHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmRleDogcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIGxldmVsOiBpLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2S2V5OiByb3dbcm93Lmxlbmd0aCAtIDFdLmtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvdy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJSb3dzLm1hcCgoY2hpbGROb2RlcywgaW5kZXgpPT57XG4gICAgICAgIGxldCByb3cgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImhlYWRlcnJvd1wiLFxuICAgICAgICAgICAga2V5OiBcImhlYWRlcnJvdy1cIiArIGluZGV4LFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgICAgICB0ZXh0VmFsdWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9KTtcbn1cbmNsYXNzICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwIGV4dGVuZHMgKDAsICQxQmZqVyRHcmlkQ29sbGVjdGlvbikge1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm9keS5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5rZXlzKCk7XG4gICAgfVxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRGaXJzdEtleSgpIHtcbiAgICAgICAgdmFyIF9nZXRGaXJzdEl0ZW07XG4gICAgICAgIHJldHVybiAoX2dldEZpcnN0SXRlbSA9ICgwLCAkMUJmalckZ2V0Rmlyc3RJdGVtKSh0aGlzLmJvZHkuY2hpbGROb2RlcykpID09PSBudWxsIHx8IF9nZXRGaXJzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRGaXJzdEl0ZW0ua2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICB2YXIgX2dldExhc3RJdGVtO1xuICAgICAgICByZXR1cm4gKF9nZXRMYXN0SXRlbSA9ICgwLCAkMUJmalckZ2V0TGFzdEl0ZW0pKHRoaXMuYm9keS5jaGlsZE5vZGVzKSkgPT09IG51bGwgfHwgX2dldExhc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0TGFzdEl0ZW0ua2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBnZXRUZXh0VmFsdWUoa2V5KSB7XG4gICAgICAgIGxldCByb3cgPSB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFyb3cpIHJldHVybiBcIlwiO1xuICAgICAgICAvLyBJZiB0aGUgcm93IGhhcyBhIHRleHRWYWx1ZSwgdXNlIHRoYXQuXG4gICAgICAgIGlmIChyb3cudGV4dFZhbHVlKSByZXR1cm4gcm93LnRleHRWYWx1ZTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNvbWJpbmUgdGhlIHRleHQgb2YgZWFjaCBvZiB0aGUgcm93IGhlYWRlciBjb2x1bW5zLlxuICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uS2V5cyA9IHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cztcbiAgICAgICAgaWYgKHJvd0hlYWRlckNvbHVtbktleXMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjZWxsIG9mIHJvdy5jaGlsZE5vZGVzKXtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1uID0gdGhpcy5jb2x1bW5zW2NlbGwuaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChyb3dIZWFkZXJDb2x1bW5LZXlzLmhhcyhjb2x1bW4ua2V5KSAmJiBjZWxsLnRleHRWYWx1ZSkgdGV4dC5wdXNoKGNlbGwudGV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IHJvd0hlYWRlckNvbHVtbktleXMuc2l6ZSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5qb2luKFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iobm9kZXMsIHByZXYsIG9wdHMpe1xuICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgICAgIC8vIEFkZCBjZWxsIGZvciBzZWxlY3Rpb24gY2hlY2tib3hlcyBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMpIHtcbiAgICAgICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICBrZXk6ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgICAgIGluZGV4OiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgPyAxIDogMCxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGlvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29sdW1ucy51bnNoaWZ0KHJvd0hlYWRlckNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNlbGwgZm9yIGRyYWcgYnV0dG9ucyBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSB7XG4gICAgICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAga2V5OiAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ0J1dHRvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29sdW1ucy51bnNoaWZ0KHJvd0hlYWRlckNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJvd3MgPSBbXTtcbiAgICAgICAgbGV0IGNvbHVtbktleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbHVtblwiOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5LZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmhhc0NoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnByb3BzLmlzUm93SGVhZGVyKSByb3dIZWFkZXJDb2x1bW5LZXlzLmFkZChub2RlLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIml0ZW1cIjpcbiAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGRvIG5vdCBnbyBpbnRvIGNoaWxkTm9kZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpdmlzaXQobm9kZSk7XG4gICAgICAgIGxldCBoZWFkZXJSb3dzID0gJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUoY29sdW1uS2V5TWFwLCBjb2x1bW5zKTtcbiAgICAgICAgaGVhZGVyUm93cy5mb3JFYWNoKChyb3csIGkpPT5yb3dzLnNwbGljZShpLCAwLCByb3cpKTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29sdW1uQ291bnQ6IGNvbHVtbnMubGVuZ3RoLFxuICAgICAgICAgICAgaXRlbXM6IHJvd3MsXG4gICAgICAgICAgICB2aXNpdE5vZGU6IChub2RlKT0+e1xuICAgICAgICAgICAgICAgIG5vZGUuY29sdW1uID0gY29sdW1uc1tub2RlLmluZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgICB0aGlzLnJvd0hlYWRlckNvbHVtbktleXMgPSByb3dIZWFkZXJDb2x1bW5LZXlzO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLmhlYWRlclJvd3MgPSBoZWFkZXJSb3dzO1xuICAgICAgICB0aGlzLl9zaXplID0gW1xuICAgICAgICAgICAgLi4uYm9keS5jaGlsZE5vZGVzXG4gICAgICAgIF0ubGVuZ3RoO1xuICAgICAgICAvLyBEZWZhdWx0IHJvdyBoZWFkZXIgY29sdW1uIHRvIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgIGlmICh0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSB0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuYWRkKHRoaXMuY29sdW1uc1syXS5rZXkpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnNbMV0ua2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuYWRkKHRoaXMuY29sdW1uc1swXS5rZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuY29uc3QgJDRhMGRkMDM2ZDQ5MmNlZTQkdmFyJE9QUE9TSVRFX1NPUlRfRElSRUNUSU9OID0ge1xuICAgIGFzY2VuZGluZzogXCJkZXNjZW5kaW5nXCIsXG4gICAgZGVzY2VuZGluZzogXCJhc2NlbmRpbmdcIlxufTtcbmZ1bmN0aW9uICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2KHByb3BzKSB7XG4gICAgbGV0IFtpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLCBzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZF0gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHsgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSA9IFwibm9uZVwiLCBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zIH0gPSBwcm9wcztcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgc2VsZWN0aW9uTW9kZSAhPT0gXCJub25lXCIsXG4gICAgICAgICAgICBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb2x1bW5zOiBbXVxuICAgICAgICB9KSwgW1xuICAgICAgICBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xuICAgIF0pO1xuICAgIGxldCBjb2xsZWN0aW9uID0gKDAsICQxQmZqVyR1c2VDb2xsZWN0aW9uKShwcm9wcywgKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKG5vZGVzKT0+bmV3ICgwLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCkobm9kZXMsIG51bGwsIGNvbnRleHQpLCBbXG4gICAgICAgIGNvbnRleHRcbiAgICBdKSwgY29udGV4dCk7XG4gICAgbGV0IHsgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIgfSA9ICgwLCAkMUJmalckdXNlR3JpZFN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEJlaGF2aW9yOiBwcm9wcy5kaXNhYmxlZEJlaGF2aW9yIHx8IFwic2VsZWN0aW9uXCJcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHByb3BzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzIHx8IGZhbHNlLFxuICAgICAgICBzb3J0RGVzY3JpcHRvcjogcHJvcHMuc29ydERlc2NyaXB0b3IsXG4gICAgICAgIGlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCB8fCBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLFxuICAgICAgICBzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQsXG4gICAgICAgIHNvcnQgKGNvbHVtbktleSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3Byb3BzX3NvcnREZXNjcmlwdG9yO1xuICAgICAgICAgICAgcHJvcHMub25Tb3J0Q2hhbmdlKHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbktleSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbiAhPT0gbnVsbCAmJiBkaXJlY3Rpb24gIT09IHZvaWQgMCA/IGRpcmVjdGlvbiA6ICgoX3Byb3BzX3NvcnREZXNjcmlwdG9yID0gcHJvcHMuc29ydERlc2NyaXB0b3IpID09PSBudWxsIHx8IF9wcm9wc19zb3J0RGVzY3JpcHRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb3BzX3NvcnREZXNjcmlwdG9yLmNvbHVtbikgPT09IGNvbHVtbktleSA/ICQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTltwcm9wcy5zb3J0RGVzY3JpcHRvci5kaXJlY3Rpb25dIDogXCJhc2NlbmRpbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlcihwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBjb2x1bW5zOiBjb2x1bW5zIH0gPSBwcm9wcztcbiAgICAvLyBDbGVhciBjb2x1bW5zIHNvIHRoZXkgYXJlbid0IGRvdWJsZSBhZGRlZCBpbiBzdHJpY3QgbW9kZS5cbiAgICBjb250ZXh0LmNvbHVtbnMgPSBbXTtcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFjb2x1bW5zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuY29sdW1ucyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgdmFsdWU6IGNvbHVtbixcbiAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjb2x1bW4pPT57XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogY29sdW1uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkKiBjb2x1bW5zO1xuICAgIH1cbn07XG4vKipcbiAqIEEgVGFibGVIZWFkZXIgaXMgYSBjb250YWluZXIgZm9yIHRoZSBDb2x1bW4gZWxlbWVudHMgaW4gYSBUYWJsZS4gQ29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkXG4gKiBhcyBjaGlsZHJlbiwgb3IgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5IHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBgY29sdW1uc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQzMTJhZTNiNTZhOTRhODZlJGV4cG9ydCRmODUwODk1YjI4N2VmMjhlID0gJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcImJvZHlcIixcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9wcy5jaGlsZHJlbiB3YXMgYSBmdW5jdGlvbiBidXQgcHJvcHMuaXRlbXMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoaXRlbSk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEEgVGFibGVCb2R5IGlzIGEgY29udGFpbmVyIGZvciB0aGUgUm93IGVsZW1lbnRzIG9mIGEgVGFibGUuIFJvd3MgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZFxuICogYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgYGl0ZW1zYCBwcm9wLlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgPSAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5O1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgeyB0aXRsZTogdGl0bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiwgY2hpbGRDb2x1bW5zOiBjaGlsZENvbHVtbnMgfSA9IHByb3BzO1xuICAgIGxldCByZW5kZXJlZCA9IHRpdGxlIHx8IGNoaWxkcmVuO1xuICAgIGxldCB0ZXh0VmFsdWUgPSBwcm9wcy50ZXh0VmFsdWUgfHwgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJzdHJpbmdcIiA/IHJlbmRlcmVkIDogXCJcIikgfHwgcHJvcHNbXCJhcmlhLWxhYmVsXCJdO1xuICAgIGxldCBmdWxsTm9kZXMgPSB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6ICEhY2hpbGRDb2x1bW5zIHx8IHRpdGxlICYmICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA+IDAsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZCxcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkQ29sdW1ucykgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRDb2x1bW5zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQ29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjaGlsZENvbHVtbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEludmFsaWRhdGUgKG5ld0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgaXQgd29ya3MuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZW4gdGhlcmUncyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgbm9kZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAvLyBCdXQsIHdlIG5lZWQgdG8ga2VlcCB0aGUgbGlzdCBvZiBjb2x1bW5zIGluIHRoZSBuZXcgY29udGV4dCB1cCB0byBkYXRlLlxuICAgICAgICAgICAgdXBkYXRlQ29udGV4dChuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZGF0ZUNvbnRleHQgPSAoY29udGV4dCk9PntcbiAgICAgICAgLy8gcmVnaXN0ZXIgbGVhZiBjb2x1bW5zIG9uIHRoZSBjb250ZXh0IHNvIHRoYXQgPFJvdz4gY2FuIGFjY2VzcyB0aGVtXG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgZnVsbE5vZGVzKWlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSBjb250ZXh0LmNvbHVtbnMucHVzaChub2RlKTtcbiAgICB9O1xuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCk7XG59O1xuLyoqXG4gKiBBIENvbHVtbiByZXByZXNlbnRzIGEgZmllbGQgb2YgZWFjaCBpdGVtIHdpdGhpbiBhIFRhYmxlLiBDb2x1bW5zIG1heSBhbHNvIGNvbnRhaW4gbmVzdGVkXG4gKiBDb2x1bW4gZWxlbWVudHMgdG8gcmVwcmVzZW50IGNvbHVtbiBncm91cHMuIE5lc3RlZCBjb2x1bW5zIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWQgYXNcbiAqIGNoaWxkcmVuLCBvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgYGNoaWxkQ29sdW1uc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQxY2QyNDQ1NTdjMmY5N2Q1JGV4cG9ydCQ4MTZiNWQ4MTEyOTVlNmJjID0gJDFjZDI0NDU1N2MyZjk3ZDUkdmFyJENvbHVtbjtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93KHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93LmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0VmFsdWU6IHRleHRWYWx1ZSwgVU5TVEFCTEVfY2hpbGRJdGVtczogVU5TVEFCTEVfY2hpbGRJdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyBjZWxscyBmaXJzdFxuICAgICAgICAgICAgaWYgKGNvbnRleHQuc2hvd0RyYWdCdXR0b25zKSB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcImhlYWRlci1kcmFnXCIsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnQnV0dG9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBjb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiKSB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcImhlYWRlclwiLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0aW9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29udGV4dC5jb2x1bW5zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkcmVuKGNvbHVtbi5rZXkpLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGNvbHVtbi5rZXkgLy8gdGhpcyBpcyBjb21iaW5lZCB3aXRoIHRoZSByb3cga2V5IGJ5IENvbGxlY3Rpb25CdWlsZGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoVU5TVEFCTEVfY2hpbGRJdGVtcykgZm9yIChsZXQgY2hpbGQgb2YgVU5TVEFCTEVfY2hpbGRJdGVtcykvLyBOb3RlOiBpbiBvcmRlciB0byByZXVzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIFRhYmxlQm9keSBmb3Igb3VyIGNoaWxkIHJvd3MsIHdlIGp1c3QgbmVlZCB0byB5aWVsZCBhIHR5cGUgYW5kIGEgdmFsdWUgaGVyZS4gQ29sbGVjdGlvbkJ1aWxkZXIgd2lsbCB0aGVuIGxvb2sgdXBcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFyZW50IHJlbmRlcmVyIGFuZCB1c2UgdGhhdCB0byBidWlsZCB0aGUgZnVsbCBub2RlIG9mIHRoaXMgY2hpbGQgcm93LCB1c2luZyB0aGUgdmFsdWUgcHJvdmlkZWQgaGVyZSB0byBnZW5lcmF0ZSB0aGUgY2VsbHNcbiAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSb3dzID0gW107XG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggPCBjb250ZXh0LmNvbHVtbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgb2YgYSBSb3cncyBjaGlsZCBDZWxscyBtdXN0IGJlIHBvc2l0aW9uZWQgYmVmb3JlIGFueSBjaGlsZCBSb3dzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkUm93cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNlbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjZWxscy5sZW5ndGggIT09IGNvbnRleHQuY29sdW1ucy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihgQ2VsbCBjb3VudCBtdXN0IG1hdGNoIGNvbHVtbiBjb3VudC4gRm91bmQgJHtjZWxscy5sZW5ndGh9IGNlbGxzIGFuZCAke2NvbnRleHQuY29sdW1ucy5sZW5ndGh9IGNvbHVtbnMuYCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGNlbGxzO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjaGlsZFJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEludmFsaWRhdGUgKG5ld0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgYWxsIHJvd3MgaWYgdGhlIGNvbHVtbnMgY2hhbmdlZC5cbiAgICAgICAgICAgIHJldHVybiBuZXdDb250ZXh0LmNvbHVtbnMubGVuZ3RoICE9PSBjb250ZXh0LmNvbHVtbnMubGVuZ3RoIHx8IG5ld0NvbnRleHQuY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IGNvbnRleHQuY29sdW1uc1tpXS5rZXkpIHx8IG5ld0NvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgIT09IGNvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgfHwgbmV3Q29udGV4dC5zaG93RHJhZ0J1dHRvbnMgIT09IGNvbnRleHQuc2hvd0RyYWdCdXR0b25zIHx8IG5ld0NvbnRleHQuc2VsZWN0aW9uTW9kZSAhPT0gY29udGV4dC5zZWxlY3Rpb25Nb2RlO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEEgUm93IHJlcHJlc2VudHMgYSBzaW5nbGUgaXRlbSBpbiBhIFRhYmxlIGFuZCBjb250YWlucyBDZWxsIGVsZW1lbnRzIGZvciBlYWNoIGNvbHVtbi5cbiAqIENlbGxzIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWQgYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uXG4gKiBiYXNlZCBvbiB0aGUgY29sdW1ucyBkZWZpbmVkIGluIHRoZSBUYWJsZUhlYWRlci5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyID0gJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdztcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGwocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgY2hpbGRyZW4gPT09IFwic3RyaW5nXCIgPyBjaGlsZHJlbiA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXSB8fCBcIlwiO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJjZWxsXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgcmVuZGVyZWQ6IGNoaWxkcmVuLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2VcbiAgICB9O1xufTtcbi8qKlxuICogQSBDZWxsIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIENvbHVtbiB3aXRoaW4gYSBUYWJsZSBSb3cuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkOTQxZDFkOWE2YTI4OTgyYSRleHBvcnQkZjZmMGMzZmU0ZWMzMDZlYSA9ICQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsO1xuXG5cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5cblxuXG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSRleHBvcnQkMzRkZmE4YTE2MjIxODVhNChwcm9wcykge1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLCBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucywgVU5TVEFCTEVfZXhwYW5kZWRLZXlzOiBwcm9wRXhwYW5kZWRLZXlzLCBVTlNUQUJMRV9kZWZhdWx0RXhwYW5kZWRLZXlzOiBwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cywgVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZTogVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBpZiAoISgwLCAkMUJmalckdGFibGVOZXN0ZWRSb3dzKSgpKSB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlIGZsYWcgZm9yIHRhYmxlIG5lc3RlZCByb3dzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgdXNlVHJlZUdyaWRTdGF0ZS5cIik7XG4gICAgbGV0IFtleHBhbmRlZEtleXMsIHNldEV4cGFuZGVkS2V5c10gPSAoMCwgJDFCZmpXJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcEV4cGFuZGVkS2V5cyA/ICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQocHJvcEV4cGFuZGVkS2V5cykgOiB1bmRlZmluZWQsIHByb3BEZWZhdWx0RXhwYW5kZWRLZXlzID8gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGNvbnZlcnRFeHBhbmRlZChwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cykgOiBuZXcgU2V0KCksIFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UpO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBzZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIixcbiAgICAgICAgICAgIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zXG4gICAgXSk7XG4gICAgbGV0IGJ1aWxkZXIgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlcikoKSwgW10pO1xuICAgIGxldCBub2RlcyA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmJ1aWxkZXIuYnVpbGQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0sIGNvbnRleHQpLCBbXG4gICAgICAgIGJ1aWxkZXIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBjb250ZXh0XG4gICAgXSk7XG4gICAgbGV0IHRyZWVHcmlkQ29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcbiAgICAgICAgcmV0dXJuICRlZTY1YTAwNTdmZDk5NTMxJHZhciRnZW5lcmF0ZVRyZWVHcmlkQ29sbGVjdGlvbihub2Rlcywge1xuICAgICAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5c1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG5vZGVzLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICBleHBhbmRlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgb25Ub2dnbGUgPSAoa2V5KT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXMoJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJHRvZ2dsZUtleShleHBhbmRlZEtleXMsIGtleSwgdHJlZUdyaWRDb2xsZWN0aW9uKSk7XG4gICAgfTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PntcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTApKHRyZWVHcmlkQ29sbGVjdGlvbi50YWJsZU5vZGVzLCBudWxsLCBjb250ZXh0KTtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHRyZWVHcmlkQ29sbGVjdGlvbi50YWJsZU5vZGVzXG4gICAgXSk7XG4gICAgbGV0IHRhYmxlU3RhdGUgPSAoMCwgJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb25cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi50YWJsZVN0YXRlLFxuICAgICAgICBrZXlNYXA6IHRyZWVHcmlkQ29sbGVjdGlvbi5rZXlNYXAsXG4gICAgICAgIHVzZXJDb2x1bW5Db3VudDogdHJlZUdyaWRDb2xsZWN0aW9uLnVzZXJDb2x1bW5Db3VudCxcbiAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXMsXG4gICAgICAgIHRvZ2dsZUtleTogb25Ub2dnbGVcbiAgICB9O1xufVxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJHRvZ2dsZUtleShjdXJyZW50RXhwYW5kZWRLZXlzLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgdXBkYXRlZEV4cGFuZGVkS2V5cztcbiAgICBpZiAoY3VycmVudEV4cGFuZGVkS2V5cyA9PT0gXCJhbGxcIikge1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzID0gbmV3IFNldChjb2xsZWN0aW9uLmZsYXR0ZW5lZFJvd3MuZmlsdGVyKChyb3cpPT5yb3cucHJvcHMuVU5TVEFCTEVfY2hpbGRJdGVtcyB8fCByb3cucHJvcHMuY2hpbGRyZW4ubGVuZ3RoID4gY29sbGVjdGlvbi51c2VyQ29sdW1uQ291bnQpLm1hcCgocm93KT0+cm93LmtleSkpO1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRFeHBhbmRlZEtleXMgPSBuZXcgU2V0KGN1cnJlbnRFeHBhbmRlZEtleXMpO1xuICAgICAgICBpZiAodXBkYXRlZEV4cGFuZGVkS2V5cy5oYXMoa2V5KSkgdXBkYXRlZEV4cGFuZGVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgZWxzZSB1cGRhdGVkRXhwYW5kZWRLZXlzLmFkZChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZEV4cGFuZGVkS2V5cztcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQoZXhwYW5kZWQpIHtcbiAgICBpZiAoIWV4cGFuZGVkKSByZXR1cm4gbmV3IFNldCgpO1xuICAgIHJldHVybiBleHBhbmRlZCA9PT0gXCJhbGxcIiA/IFwiYWxsXCIgOiBuZXcgU2V0KGV4cGFuZGVkKTtcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciRnZW5lcmF0ZVRyZWVHcmlkQ29sbGVjdGlvbihub2Rlcywgb3B0cykge1xuICAgIGxldCB7IGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzID0gbmV3IFNldCgpIH0gPSBvcHRzO1xuICAgIGxldCBib2R5O1xuICAgIGxldCBmbGF0dGVuZWRSb3dzID0gW107XG4gICAgbGV0IGNvbHVtbkNvdW50ID0gMDtcbiAgICBsZXQgdXNlckNvbHVtbkNvdW50ID0gMDtcbiAgICBsZXQgb3JpZ2luYWxDb2x1bW5zID0gW107XG4gICAgbGV0IGtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSBjb2x1bW5Db3VudCsrO1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSBjb2x1bW5Db3VudCsrO1xuICAgIGxldCB0b3BMZXZlbFJvd3MgPSBbXTtcbiAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xuICAgICAgICAgICAgICAgIGtleU1hcC5zZXQoYm9keS5rZXksIGJvZHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbHVtblwiOlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSB1c2VyQ29sdW1uQ291bnQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSb3dzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJjb2x1bW5cIikgb3JpZ2luYWxDb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgICAgIHZpc2l0KG5vZGUpO1xuICAgIH1cbiAgICBjb2x1bW5Db3VudCArPSB1c2VyQ29sdW1uQ291bnQ7XG4gICAgLy8gVXBkYXRlIGVhY2ggZ3JpZCBub2RlIGluIHRoZSB0cmVlZ3JpZCB0YWJsZSB3aXRoIHZhbHVlcyBzcGVjaWZpYyB0byBhIHRyZWVncmlkIHN0cnVjdHVyZS4gQWxzbyBzdG9yZSBhIHNldCBvZiBmbGF0dGVuZWQgcm93IG5vZGVzIGZvciBUYWJsZUNvbGxlY3Rpb24gdG8gY29uc3VtZVxuICAgIGxldCBnbG9iYWxSb3dDb3VudCA9IDA7XG4gICAgbGV0IHZpc2l0Tm9kZSA9IChub2RlLCBpKT0+e1xuICAgICAgICAvLyBDbG9uZSByb3cgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIHNvIG1vZGlmaWNhdGlvbnMgdG8gdGhlIG5vZGUgZm9yIHRyZWVncmlkIHNwZWNpZmljIHZhbHVlcyBhcmVuJ3QgYXBwbGllZCBvbiB0aGUgbm9kZXMgcHJvdmlkZWRcbiAgICAgICAgLy8gdG8gVGFibGVDb2xsZWN0aW9uLiBJbmRleCwgbGV2ZWwsIGFuZCBwYXJlbnQga2V5cyBhcmUgYWxsIGNoYW5nZWQgdG8gcmVmbGVjdCBhIGZsYXR0ZW5lZCByb3cgc3RydWN0dXJlIHJhdGhlciB0aGFuIHRoZSB0cmVlZ3JpZCBzdHJ1Y3R1cmVcbiAgICAgICAgLy8gdmFsdWVzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCB2aWEgQ29sbGVjdGlvbkJ1aWxkZXJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpaWYgKGNoaWxkLnR5cGUgPT09IFwiY2VsbFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxDbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChjZWxsQ2xvbmUuaW5kZXggKyAxID09PSBjb2x1bW5Db3VudCkgY2VsbENsb25lLm5leHRLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNlbGxDbG9uZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNsb25lID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICBwYXJlbnRLZXk6IGJvZHkua2V5LFxuICAgICAgICAgICAgICAgIGxldmVsOiAxLFxuICAgICAgICAgICAgICAgIGluZGV4OiBnbG9iYWxSb3dDb3VudCsrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmxhdHRlbmVkUm93cy5wdXNoKGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gQXNzaWduIGluZGV4T2ZUeXBlIHRvIGNlbGxzIGFuZCByb3dzIGZvciBhcmlhLXBvc2luc2V0XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwicGxhY2Vob2xkZXJcIiAmJiBub2RlLnR5cGUgIT09IFwiY29sdW1uXCIpIG5ld1Byb3BzW1wiaW5kZXhPZlR5cGVcIl0gPSBpO1xuICAgICAgICAvLyBVc2UgT2JqZWN0LmFzc2lnbiBpbnN0ZWFkIG9mIHNwcmVhZCB0byBwcmVzZXJ2ZSBvYmplY3QgcmVmZXJlbmNlIGZvciBrZXlNYXAuIEFsc28gZW5zdXJlcyByZXRyaWV2aW5nIG5vZGVzXG4gICAgICAgIC8vIHZpYSAuY2hpbGROb2RlcyByZXR1cm5zIHRoZSBzYW1lIG9iamVjdCBhcyB0aGUgb25lIGZvdW5kIHZpYSBrZXlNYXAgbG9vayB1cFxuICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIG5ld1Byb3BzKTtcbiAgICAgICAga2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgICAgbGV0IHJvd0luZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmICghKGNoaWxkLnR5cGUgPT09IFwiaXRlbVwiICYmIGV4cGFuZGVkS2V5cyAhPT0gXCJhbGxcIiAmJiAhZXhwYW5kZWRLZXlzLmhhcyhub2RlLmtleSkpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50S2V5ID09IG51bGwpIC8vIGlmIGNoaWxkIGlzIGEgY2VsbC9leHBhbmRlZCByb3cvY29sdW1uIGFuZCB0aGUgcGFyZW50IGtleSBpc24ndCBhbHJlYWR5IGVzdGFibGlzaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBtYXRjaCBjaGlsZCBub2RlIHRvIHBhcmVudCByb3dcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUubmV4dEtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcmV2S2V5ID0gbGFzdE5vZGUua2V5O1xuICAgICAgICAgICAgfSBlbHNlIGNoaWxkLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiaXRlbVwiKSB2aXNpdE5vZGUoY2hpbGQsIHJvd0luZGV4KyspO1xuICAgICAgICAgICAgZWxzZSAvLyBXZSBlbmZvcmNlIHRoYXQgdGhlIGNlbGxzIGNvbWUgYmVmb3JlIHJvd3Mgc28gY2FuIGp1c3QgcmV1c2UgY2VsbCBpbmRleFxuICAgICAgICAgICAgdmlzaXROb2RlKGNoaWxkLCBjaGlsZC5pbmRleCk7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZSkgbGFzdE5vZGUubmV4dEtleSA9IG51bGw7XG4gICAgfTtcbiAgICBsZXQgbGFzdDtcbiAgICB0b3BMZXZlbFJvd3MuZm9yRWFjaCgobm9kZSwgaSk9PntcbiAgICAgICAgdmlzaXROb2RlKG5vZGUsIGkpO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICBub2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgfSBlbHNlIG5vZGUucHJldktleSA9IG51bGw7XG4gICAgICAgIGxhc3QgPSBub2RlO1xuICAgIH0pO1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleU1hcDoga2V5TWFwLFxuICAgICAgICB1c2VyQ29sdW1uQ291bnQ6IHVzZXJDb2x1bW5Db3VudCxcbiAgICAgICAgZmxhdHRlbmVkUm93czogZmxhdHRlbmVkUm93cyxcbiAgICAgICAgdGFibGVOb2RlczogW1xuICAgICAgICAgICAgLi4ub3JpZ2luYWxDb2x1bW5zLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmJvZHksXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogZmxhdHRlbmVkUm93c1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOSBhcyB1c2VUYWJsZUNvbHVtblJlc2l6ZVN0YXRlLCAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNiBhcyB1c2VUYWJsZVN0YXRlLCAkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSBhcyBUYWJsZUhlYWRlciwgJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTcgYXMgVGFibGVCb2R5LCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyBhcyBDb2x1bW4sICQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyIGFzIFJvdywgJDk0MWQxZDlhNmEyODk4MmEkZXhwb3J0JGY2ZjBjM2ZlNGVjMzA2ZWEgYXMgQ2VsbCwgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24gYXMgU2VjdGlvbiwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAgYXMgVGFibGVDb2xsZWN0aW9uLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZSBhcyBidWlsZEhlYWRlclJvd3MsICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIGFzIFRhYmxlQ29sdW1uTGF5b3V0LCAkZWU2NWEwMDU3ZmQ5OTUzMSRleHBvcnQkMzRkZmE4YTE2MjIxODVhNCBhcyBVTlNUQUJMRV91c2VUcmVlR3JpZFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/table/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tabs/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTabListState: () => (/* binding */ $76f919a04c5a7d14$export$4ba071daf4e486)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nfunction $76f919a04c5a7d14$export$4ba071daf4e486(props) {\n    var _props_defaultSelectedKey;\n    let state = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        suppressTextValueWarning: true,\n        defaultSelectedKey: (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : $76f919a04c5a7d14$var$findDefaultSelectedKey(props.collection, props.disabledKeys ? new Set(props.disabledKeys) : new Set())\n    });\n    let { selectionManager: selectionManager, collection: collection, selectedKey: currentSelectedKey } = state;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentSelectedKey);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)\n        let selectedKey = currentSelectedKey;\n        if (selectionManager.isEmpty || !collection.getItem(selectedKey)) {\n            selectedKey = $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, state.disabledKeys);\n            if (selectedKey != null) // directly set selection because replace/toggle selection won't consider disabled keys\n            selectionManager.setSelectedKeys([\n                selectedKey\n            ]);\n        }\n        // If the tablist doesn't have focus and the selected key changes or if there isn't a focused key yet, change focused key to the selected key if it exists.\n        if (selectedKey != null && selectionManager.focusedKey == null || !selectionManager.isFocused && selectedKey !== lastSelectedKey.current) selectionManager.setFocusedKey(selectedKey);\n        lastSelectedKey.current = selectedKey;\n    });\n    return {\n        ...state,\n        isDisabled: props.isDisabled || false\n    };\n}\nfunction $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, disabledKeys) {\n    let selectedKey = null;\n    if (collection) {\n        selectedKey = collection.getFirstKey();\n        // loop over tabs until we find one that isn't disabled and select that\n        while(disabledKeys.has(selectedKey) && selectedKey !== collection.getLastKey())selectedKey = collection.getKeyAfter(selectedKey);\n        // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last\n        if (disabledKeys.has(selectedKey) && selectedKey === collection.getLastKey()) selectedKey = collection.getFirstKey();\n    }\n    return selectedKey;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFicy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZFO0FBQ21COztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix5RUFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsOEZBQThGO0FBQ3hHLDhCQUE4Qix5Q0FBYTtBQUMzQyxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS29FO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWxmYS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90YWJzL2Rpc3QvaW1wb3J0Lm1qcz9mMGNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlUmVmIGFzICRpakhLWiR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkaWpIS1okdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIGFzICRpakhLWiR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9saXN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ3NmY5MTlhMDRjNWE3ZDE0JGV4cG9ydCQ0YmEwNzFkYWY0ZTQ4Nihwcm9wcykge1xuICAgIHZhciBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5O1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkaWpIS1okdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmc6IHRydWUsXG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZEtleTogKF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgPSBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgIT09IHZvaWQgMCA/IF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgOiAkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleShwcm9wcy5jb2xsZWN0aW9uLCBwcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCkpXG4gICAgfSk7XG4gICAgbGV0IHsgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlciwgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgc2VsZWN0ZWRLZXk6IGN1cnJlbnRTZWxlY3RlZEtleSB9ID0gc3RhdGU7XG4gICAgbGV0IGxhc3RTZWxlY3RlZEtleSA9ICgwLCAkaWpIS1okdXNlUmVmKShjdXJyZW50U2VsZWN0ZWRLZXkpO1xuICAgICgwLCAkaWpIS1okdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgYSB0YWIgaXMgYWx3YXlzIHNlbGVjdGVkIChpbiBjYXNlIG5vIHNlbGVjdGVkIGtleSB3YXMgc3BlY2lmaWVkIG9yIGlmIHNlbGVjdGVkIGl0ZW0gd2FzIGRlbGV0ZWQgZnJvbSBjb2xsZWN0aW9uKVxuICAgICAgICBsZXQgc2VsZWN0ZWRLZXkgPSBjdXJyZW50U2VsZWN0ZWRLZXk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25NYW5hZ2VyLmlzRW1wdHkgfHwgIWNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5ID0gJDc2ZjkxOWEwNGM1YTdkMTQkdmFyJGZpbmREZWZhdWx0U2VsZWN0ZWRLZXkoY29sbGVjdGlvbiwgc3RhdGUuZGlzYWJsZWRLZXlzKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEtleSAhPSBudWxsKSAvLyBkaXJlY3RseSBzZXQgc2VsZWN0aW9uIGJlY2F1c2UgcmVwbGFjZS90b2dnbGUgc2VsZWN0aW9uIHdvbid0IGNvbnNpZGVyIGRpc2FibGVkIGtleXNcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hbmFnZXIuc2V0U2VsZWN0ZWRLZXlzKFtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEtleVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHRhYmxpc3QgZG9lc24ndCBoYXZlIGZvY3VzIGFuZCB0aGUgc2VsZWN0ZWQga2V5IGNoYW5nZXMgb3IgaWYgdGhlcmUgaXNuJ3QgYSBmb2N1c2VkIGtleSB5ZXQsIGNoYW5nZSBmb2N1c2VkIGtleSB0byB0aGUgc2VsZWN0ZWQga2V5IGlmIGl0IGV4aXN0cy5cbiAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwgJiYgc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5ID09IG51bGwgfHwgIXNlbGVjdGlvbk1hbmFnZXIuaXNGb2N1c2VkICYmIHNlbGVjdGVkS2V5ICE9PSBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCkgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkS2V5KHNlbGVjdGVkS2V5KTtcbiAgICAgICAgbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQgPSBzZWxlY3RlZEtleTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXNEaXNhYmxlZDogcHJvcHMuaXNEaXNhYmxlZCB8fCBmYWxzZVxuICAgIH07XG59XG5mdW5jdGlvbiAkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleShjb2xsZWN0aW9uLCBkaXNhYmxlZEtleXMpIHtcbiAgICBsZXQgc2VsZWN0ZWRLZXkgPSBudWxsO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGVkS2V5ID0gY29sbGVjdGlvbi5nZXRGaXJzdEtleSgpO1xuICAgICAgICAvLyBsb29wIG92ZXIgdGFicyB1bnRpbCB3ZSBmaW5kIG9uZSB0aGF0IGlzbid0IGRpc2FibGVkIGFuZCBzZWxlY3QgdGhhdFxuICAgICAgICB3aGlsZShkaXNhYmxlZEtleXMuaGFzKHNlbGVjdGVkS2V5KSAmJiBzZWxlY3RlZEtleSAhPT0gY29sbGVjdGlvbi5nZXRMYXN0S2V5KCkpc2VsZWN0ZWRLZXkgPSBjb2xsZWN0aW9uLmdldEtleUFmdGVyKHNlbGVjdGVkS2V5KTtcbiAgICAgICAgLy8gaWYgdGhpcyBjaGVjayBpcyB0cnVlLCB0aGVuIGV2ZXJ5IGl0ZW0gaXMgZGlzYWJsZWQsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVmYXVsdCB0byB0aGUgZmlyc3Qga2V5IHRoYW4gdGhlIGxhc3RcbiAgICAgICAgaWYgKGRpc2FibGVkS2V5cy5oYXMoc2VsZWN0ZWRLZXkpICYmIHNlbGVjdGVkS2V5ID09PSBjb2xsZWN0aW9uLmdldExhc3RLZXkoKSkgc2VsZWN0ZWRLZXkgPSBjb2xsZWN0aW9uLmdldEZpcnN0S2V5KCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZEtleTtcbn1cblxuXG5cblxuZXhwb3J0IHskNzZmOTE5YTA0YzVhN2QxNCRleHBvcnQkNGJhMDcxZGFmNGU0ODYgYXMgdXNlVGFiTGlzdFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/toggle/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useToggleState: () => (/* binding */ $3017fa7ffdddec74$export$8042c6c013fd5226)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {\n    let { isReadOnly: isReadOnly } = props;\n    // have to provide an empty function so useControlledState doesn't throw a fit\n    // can't use useControlledState's prop calling because we need the event object from the change\n    let [isSelected, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.isSelected, props.defaultSelected || false, props.onChange);\n    function updateSelected(value) {\n        if (!isReadOnly) setSelected(value);\n    }\n    function toggleState() {\n        if (!isReadOnly) setSelected(!isSelected);\n    }\n    return {\n        isSelected: isSelected,\n        setSelected: updateSelected,\n        toggle: toggleState\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQSx3Q0FBd0Msb0VBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLcUU7QUFDckUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGZhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RvZ2dsZS9kaXN0L2ltcG9ydC5tanM/YTM0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkYk9rYWUkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQzMDE3ZmE3ZmZkZGRlYzc0JGV4cG9ydCQ4MDQyYzZjMDEzZmQ1MjI2KHByb3BzID0ge30pIHtcbiAgICBsZXQgeyBpc1JlYWRPbmx5OiBpc1JlYWRPbmx5IH0gPSBwcm9wcztcbiAgICAvLyBoYXZlIHRvIHByb3ZpZGUgYW4gZW1wdHkgZnVuY3Rpb24gc28gdXNlQ29udHJvbGxlZFN0YXRlIGRvZXNuJ3QgdGhyb3cgYSBmaXRcbiAgICAvLyBjYW4ndCB1c2UgdXNlQ29udHJvbGxlZFN0YXRlJ3MgcHJvcCBjYWxsaW5nIGJlY2F1c2Ugd2UgbmVlZCB0aGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGNoYW5nZVxuICAgIGxldCBbaXNTZWxlY3RlZCwgc2V0U2VsZWN0ZWRdID0gKDAsICRiT2thZSR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLmlzU2VsZWN0ZWQsIHByb3BzLmRlZmF1bHRTZWxlY3RlZCB8fCBmYWxzZSwgcHJvcHMub25DaGFuZ2UpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNSZWFkT25seSkgc2V0U2VsZWN0ZWQodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSBzZXRTZWxlY3RlZCghaXNTZWxlY3RlZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgICAgIHNldFNlbGVjdGVkOiB1cGRhdGVTZWxlY3RlZCxcbiAgICAgICAgdG9nZ2xlOiB0b2dnbGVTdGF0ZVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYgYXMgdXNlVG9nZ2xlU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@react-stately/tooltip/dist/import.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTooltipTriggerState: () => (/* binding */ $8796f90736e175cb$export$4d40659c25ecb50b)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nconst $8796f90736e175cb$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design\nconst $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;\nlet $8796f90736e175cb$var$tooltips = {};\nlet $8796f90736e175cb$var$tooltipId = 0;\nlet $8796f90736e175cb$var$globalWarmedUp = false;\nlet $8796f90736e175cb$var$globalWarmUpTimeout = null;\nlet $8796f90736e175cb$var$globalCooldownTimeout = null;\nfunction $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {\n    let { delay: delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay: closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;\n    let { isOpen: isOpen, open: open, close: close } = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`${++$8796f90736e175cb$var$tooltipId}`, []);\n    let closeTimeout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let ensureTooltipEntry = ()=>{\n        $8796f90736e175cb$var$tooltips[id] = hideTooltip;\n    };\n    let closeOpenTooltips = ()=>{\n        for(let hideTooltipId in $8796f90736e175cb$var$tooltips)if (hideTooltipId !== id) {\n            $8796f90736e175cb$var$tooltips[hideTooltipId](true);\n            delete $8796f90736e175cb$var$tooltips[hideTooltipId];\n        }\n    };\n    let showTooltip = ()=>{\n        clearTimeout(closeTimeout.current);\n        closeTimeout.current = null;\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        $8796f90736e175cb$var$globalWarmedUp = true;\n        open();\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalCooldownTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = null;\n        }\n    };\n    let hideTooltip = (immediate)=>{\n        if (immediate || closeDelay <= 0) {\n            clearTimeout(closeTimeout.current);\n            closeTimeout.current = null;\n            close();\n        } else if (!closeTimeout.current) closeTimeout.current = setTimeout(()=>{\n            closeTimeout.current = null;\n            close();\n        }, closeDelay);\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalWarmedUp) {\n            if ($8796f90736e175cb$var$globalCooldownTimeout) clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(()=>{\n                delete $8796f90736e175cb$var$tooltips[id];\n                $8796f90736e175cb$var$globalCooldownTimeout = null;\n                $8796f90736e175cb$var$globalWarmedUp = false;\n            }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));\n        }\n    };\n    let warmupTooltip = ()=>{\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp) $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(()=>{\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n            $8796f90736e175cb$var$globalWarmedUp = true;\n            showTooltip();\n        }, delay);\n        else if (!isOpen) showTooltip();\n    };\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearTimeout(closeTimeout.current);\n            let tooltip = $8796f90736e175cb$var$tooltips[id];\n            if (tooltip) delete $8796f90736e175cb$var$tooltips[id];\n        };\n    }, [\n        id\n    ]);\n    return {\n        isOpen: isOpen,\n        open: (immediate)=>{\n            if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();\n            else showTooltip();\n        },\n        close: hideTooltip\n    };\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdHO0FBQ1I7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFVBQVUsc0hBQXNIO0FBQ2hJLFVBQVUsMkNBQTJDLE1BQU0sMkVBQTZCO0FBQ3hGLGlCQUFpQiwwQ0FBYyxTQUFTLGtDQUFrQztBQUMxRSwyQkFBMkIseUNBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7OztBQUs2RTtBQUM3RSIsInNvdXJjZXMiOlsid2VicGFjazovL2FsZmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanM/NTIyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU1lbW8gYXMgJDFPaERxJHVzZU1lbW8sIHVzZVJlZiBhcyAkMU9oRHEkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDFPaERxJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZU92ZXJsYXlUcmlnZ2VyU3RhdGUgYXMgJDFPaERxJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9vdmVybGF5c1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jb25zdCAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9ERUxBWSA9IDE1MDA7IC8vIHRoaXMgc2VlbXMgdG8gYmUgYSAxLjUgc2Vjb25kIGRlbGF5LCBjaGVjayB3aXRoIGRlc2lnblxuY29uc3QgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfQ09PTERPV04gPSA1MDA7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzID0ge307XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBJZCA9IDA7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwID0gZmFsc2U7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgPSBudWxsO1xubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBudWxsO1xuZnVuY3Rpb24gJDg3OTZmOTA3MzZlMTc1Y2IkZXhwb3J0JDRkNDA2NTljMjVlY2I1MGIocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGRlbGF5OiBkZWxheSA9ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0RFTEFZLCBjbG9zZURlbGF5OiBjbG9zZURlbGF5ID0gJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfQ09PTERPV04gfSA9IHByb3BzO1xuICAgIGxldCB7IGlzT3BlbjogaXNPcGVuLCBvcGVuOiBvcGVuLCBjbG9zZTogY2xvc2UgfSA9ICgwLCAkMU9oRHEkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSkocHJvcHMpO1xuICAgIGxldCBpZCA9ICgwLCAkMU9oRHEkdXNlTWVtbykoKCk9PmAkeysrJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBJZH1gLCBbXSk7XG4gICAgbGV0IGNsb3NlVGltZW91dCA9ICgwLCAkMU9oRHEkdXNlUmVmKSgpO1xuICAgIGxldCBlbnN1cmVUb29sdGlwRW50cnkgPSAoKT0+e1xuICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdID0gaGlkZVRvb2x0aXA7XG4gICAgfTtcbiAgICBsZXQgY2xvc2VPcGVuVG9vbHRpcHMgPSAoKT0+e1xuICAgICAgICBmb3IobGV0IGhpZGVUb29sdGlwSWQgaW4gJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzKWlmIChoaWRlVG9vbHRpcElkICE9PSBpZCkge1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2hpZGVUb29sdGlwSWRdKHRydWUpO1xuICAgICAgICAgICAgZGVsZXRlICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1toaWRlVG9vbHRpcElkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHNob3dUb29sdGlwID0gKCk9PntcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjbG9zZU9wZW5Ub29sdGlwcygpO1xuICAgICAgICBlbnN1cmVUb29sdGlwRW50cnkoKTtcbiAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwID0gdHJ1ZTtcbiAgICAgICAgb3BlbigpO1xuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCk7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgaGlkZVRvb2x0aXAgPSAoaW1tZWRpYXRlKT0+e1xuICAgICAgICBpZiAoaW1tZWRpYXRlIHx8IGNsb3NlRGVsYXkgPD0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgICAgIGNsb3NlVGltZW91dC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNsb3NlVGltZW91dC5jdXJyZW50KSBjbG9zZVRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIGNsb3NlVGltZW91dC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH0sIGNsb3NlRGVsYXkpO1xuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCk7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCkge1xuICAgICAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgZGVsZXRlICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF07XG4gICAgICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwID0gZmFsc2U7XG4gICAgICAgICAgICB9LCBNYXRoLm1heCgkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiwgY2xvc2VEZWxheSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgd2FybXVwVG9vbHRpcCA9ICgpPT57XG4gICAgICAgIGNsb3NlT3BlblRvb2x0aXBzKCk7XG4gICAgICAgIGVuc3VyZVRvb2x0aXBFbnRyeSgpO1xuICAgICAgICBpZiAoIWlzT3BlbiAmJiAhJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgJiYgISQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCkgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSB0cnVlO1xuICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBlbHNlIGlmICghaXNPcGVuKSBzaG93VG9vbHRpcCgpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJDFPaERxJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICAgICAgbGV0IHRvb2x0aXAgPSAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXApIGRlbGV0ZSAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaWRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc09wZW46IGlzT3BlbixcbiAgICAgICAgb3BlbjogKGltbWVkaWF0ZSk9PntcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlICYmIGRlbGF5ID4gMCAmJiAhY2xvc2VUaW1lb3V0LmN1cnJlbnQpIHdhcm11cFRvb2x0aXAoKTtcbiAgICAgICAgICAgIGVsc2Ugc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGhpZGVUb29sdGlwXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskODc5NmY5MDczNmUxNzVjYiRleHBvcnQkNGQ0MDY1OWMyNWVjYjUwYiBhcyB1c2VUb29sdGlwVHJpZ2dlclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tree/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tree/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeCollection: () => (/* binding */ $05ca4cd7c4a5a999$export$863faf230ee2118a),\n/* harmony export */   useTreeState: () => (/* binding */ $875d6693e12af071$export$728d6ba534403756)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $05ca4cd7c4a5a999$export$863faf230ee2118a {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    constructor(nodes, { expandedKeys: expandedKeys } = {}){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        expandedKeys = expandedKeys || new Set();\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && (node.type === \"section\" || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\n\n\n\n\nfunction $875d6693e12af071$export$728d6ba534403756(props) {\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let tree = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {\n            expandedKeys: expandedKeys\n        }), [\n        expandedKeys\n    ]), null);\n    // Reset focused key if that item is deleted from the collection.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        tree,\n        selectionState.focusedKey\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));\n    };\n    return {\n        collection: tree,\n        expandedKeys: expandedKeys,\n        disabledKeys: disabledKeys,\n        toggleKey: onToggle,\n        setExpandedKeys: setExpandedKeys,\n        selectionManager: new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.SelectionManager)(tree, selectionState)\n    };\n}\nfunction $875d6693e12af071$var$toggleKey(set, key) {\n    let res = new Set(set);\n    if (res.has(key)) res.delete(key);\n    else res.add(key);\n    return res;\n}\n\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtIO0FBQ2tDO0FBQ25FO0FBQ0k7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkIsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLDhDQUE4QyxvRUFBeUI7QUFDdkUsNkJBQTZCLCtFQUFnQztBQUM3RCwyQkFBMkIsMENBQWM7QUFDekM7QUFDQTtBQUNBLG1CQUFtQixxRUFBb0IsYUFBYSw4Q0FBa0I7QUFDdEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0VBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1nSTtBQUNoSSIsInNvdXJjZXMiOlsid2VicGFjazovL2FsZmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanM/YjRkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU1lbW8gYXMgJDFPb1RqJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQxT29UaiR1c2VDYWxsYmFjaywgdXNlRWZmZWN0IGFzICQxT29UaiR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIGFzICQxT29UaiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCBTZWxlY3Rpb25NYW5hZ2VyIGFzICQxT29UaiRTZWxlY3Rpb25NYW5hZ2VyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uXCI7XG5pbXBvcnQge3VzZUNvbGxlY3Rpb24gYXMgJDFPb1RqJHVzZUNvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDFPb1RqJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5pdGVyYWJsZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5zaXplO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0S2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0S2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyB9ID0ge30pe1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG5vZGVzO1xuICAgICAgICBleHBhbmRlZEtleXMgPSBleHBhbmRlZEtleXMgfHwgbmV3IFNldCgpO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzICYmIChub2RlLnR5cGUgPT09IFwic2VjdGlvblwiIHx8IGV4cGFuZGVkS2V5cy5oYXMobm9kZS5rZXkpKSkgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IFtrZXksIG5vZGVdIG9mIHRoaXMua2V5TWFwKXtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSBub2RlLmluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICAgIGxhc3QgPSBub2RlO1xuICAgICAgICAgICAgLy8gU2V0IG5leHRLZXkgYXMgdW5kZWZpbmVkIHNpbmNlIHRoaXMgbWlnaHQgYmUgdGhlIGxhc3Qgbm9kZVxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgdGhlIGxhc3Qgbm9kZSwgbGFzdC5uZXh0S2V5IHdpbGwgcHJvcGVybHkgc2V0IGF0IHN0YXJ0IG9mIG5ldyBsb29wXG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0S2V5ID0gbGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmtleTtcbiAgICB9XG59XG5cblxuXG5cbmZ1bmN0aW9uICQ4NzVkNjY5M2UxMmFmMDcxJGV4cG9ydCQ3MjhkNmJhNTM0NDAzNzU2KHByb3BzKSB7XG4gICAgbGV0IFtleHBhbmRlZEtleXMsIHNldEV4cGFuZGVkS2V5c10gPSAoMCwgJDFPb1RqJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuZXhwYW5kZWRLZXlzID8gbmV3IFNldChwcm9wcy5leHBhbmRlZEtleXMpIDogdW5kZWZpbmVkLCBwcm9wcy5kZWZhdWx0RXhwYW5kZWRLZXlzID8gbmV3IFNldChwcm9wcy5kZWZhdWx0RXhwYW5kZWRLZXlzKSA6IG5ldyBTZXQoKSwgcHJvcHMub25FeHBhbmRlZENoYW5nZSk7XG4gICAgbGV0IHNlbGVjdGlvblN0YXRlID0gKDAsICQxT29UaiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGRpc2FibGVkS2V5cyA9ICgwLCAkMU9vVGokdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgdHJlZSA9ICgwLCAkMU9vVGokdXNlQ29sbGVjdGlvbikocHJvcHMsICgwLCAkMU9vVGokdXNlQ2FsbGJhY2spKChub2Rlcyk9Pm5ldyAoMCwgJDA1Y2E0Y2Q3YzRhNWE5OTkkZXhwb3J0JDg2M2ZhZjIzMGVlMjExOGEpKG5vZGVzLCB7XG4gICAgICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5c1xuICAgICAgICB9KSwgW1xuICAgICAgICBleHBhbmRlZEtleXNcbiAgICBdKSwgbnVsbCk7XG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAoMCwgJDFPb1RqJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkgIT0gbnVsbCAmJiAhdHJlZS5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpKSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KG51bGwpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXlcbiAgICBdKTtcbiAgICBsZXQgb25Ub2dnbGUgPSAoa2V5KT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXMoJDg3NWQ2NjkzZTEyYWYwNzEkdmFyJHRvZ2dsZUtleShleHBhbmRlZEtleXMsIGtleSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogdHJlZSxcbiAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXMsXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICB0b2dnbGVLZXk6IG9uVG9nZ2xlLFxuICAgICAgICBzZXRFeHBhbmRlZEtleXM6IHNldEV4cGFuZGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogbmV3ICgwLCAkMU9vVGokU2VsZWN0aW9uTWFuYWdlcikodHJlZSwgc2VsZWN0aW9uU3RhdGUpXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ4NzVkNjY5M2UxMmFmMDcxJHZhciR0b2dnbGVLZXkoc2V0LCBrZXkpIHtcbiAgICBsZXQgcmVzID0gbmV3IFNldChzZXQpO1xuICAgIGlmIChyZXMuaGFzKGtleSkpIHJlcy5kZWxldGUoa2V5KTtcbiAgICBlbHNlIHJlcy5hZGQoa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5cblxuXG5cbmV4cG9ydCB7JDg3NWQ2NjkzZTEyYWYwNzEkZXhwb3J0JDcyOGQ2YmE1MzQ0MDM3NTYgYXMgdXNlVHJlZVN0YXRlLCAkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSBhcyBUcmVlQ29sbGVjdGlvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tree/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/utils/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/utils/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nfunction $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // If uncontrolled, mutate the currentValue local variable so that\n            // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJOztBQUU3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBZTtBQUN6RCw4QkFBOEIseUNBQWE7QUFDM0M7QUFDQSxRQUFRLDRDQUFnQjtBQUN4QjtBQUNBLDJGQUEyRiwrQ0FBK0MsS0FBSyw2Q0FBNkM7QUFDNUw7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLc1A7QUFDdFAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGZhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3V0aWxzL2Rpc3QvaW1wb3J0Lm1qcz9kZTc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU3RhdGUgYXMgJDZpbXVoJHVzZVN0YXRlLCB1c2VSZWYgYXMgJDZpbXVoJHVzZVJlZiwgdXNlRWZmZWN0IGFzICQ2aW11aCR1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIGFzICQ2aW11aCR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBvbkNoYW5nZSkge1xuICAgIGxldCBbc3RhdGVWYWx1ZSwgc2V0U3RhdGVWYWx1ZV0gPSAoMCwgJDZpbXVoJHVzZVN0YXRlKSh2YWx1ZSB8fCBkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBpc0NvbnRyb2xsZWRSZWYgPSAoMCwgJDZpbXVoJHVzZVJlZikodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgbGV0IGlzQ29udHJvbGxlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgKDAsICQ2aW11aCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCB3YXNDb250cm9sbGVkID0gaXNDb250cm9sbGVkUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh3YXNDb250cm9sbGVkICE9PSBpc0NvbnRyb2xsZWQpIGNvbnNvbGUud2FybihgV0FSTjogQSBjb21wb25lbnQgY2hhbmdlZCBmcm9tICR7d2FzQ29udHJvbGxlZCA/IFwiY29udHJvbGxlZFwiIDogXCJ1bmNvbnRyb2xsZWRcIn0gdG8gJHtpc0NvbnRyb2xsZWQgPyBcImNvbnRyb2xsZWRcIiA6IFwidW5jb250cm9sbGVkXCJ9LmApO1xuICAgICAgICBpc0NvbnRyb2xsZWRSZWYuY3VycmVudCA9IGlzQ29udHJvbGxlZDtcbiAgICB9LCBbXG4gICAgICAgIGlzQ29udHJvbGxlZFxuICAgIF0pO1xuICAgIGxldCBjdXJyZW50VmFsdWUgPSBpc0NvbnRyb2xsZWQgPyB2YWx1ZSA6IHN0YXRlVmFsdWU7XG4gICAgbGV0IHNldFZhbHVlID0gKDAsICQ2aW11aCR1c2VDYWxsYmFjaykoKHZhbHVlLCAuLi5hcmdzKT0+e1xuICAgICAgICBsZXQgb25DaGFuZ2VDYWxsZXIgPSAodmFsdWUsIC4uLm9uQ2hhbmdlQXJncyk9PntcbiAgICAgICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmlzKGN1cnJlbnRWYWx1ZSwgdmFsdWUpKSBvbkNoYW5nZSh2YWx1ZSwgLi4ub25DaGFuZ2VBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSAvLyBJZiB1bmNvbnRyb2xsZWQsIG11dGF0ZSB0aGUgY3VycmVudFZhbHVlIGxvY2FsIHZhcmlhYmxlIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgc2V0U3RhdGUgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSB2YWx1ZSBvbmx5IGVtaXRzIG9uQ2hhbmdlIG9uY2UuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGEgcmVmIGZvciB0aGlzIGJlY2F1c2Ugd2Ugc3BlY2lmaWNhbGx5IF9kb18gd2FudCB0aGUgdmFsdWUgdG9cbiAgICAgICAgICAgIC8vIHJlc2V0IGV2ZXJ5IHJlbmRlciwgYW5kIGFzc2lnbmluZyB0byBhIHJlZiBpbiByZW5kZXIgYnJlYWtzIGFib3J0ZWQgc3VzcGVuZGVkIHJlbmRlcnMuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXZSBjYW4gbm90IHN1cHBvcnQgYSBmdW5jdGlvbiBjYWxsYmFjay4gU2VlIEdpdGh1YiBJc3N1ZXMgZm9yIGRldGFpbHMgaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2lzc3Vlcy8yMzIwXCIpO1xuICAgICAgICAgICAgLy8gdGhpcyBzdXBwb3J0cyBmdW5jdGlvbmFsIHVwZGF0ZXMgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJlZmVyZW5jZS5odG1sI2Z1bmN0aW9uYWwtdXBkYXRlc1xuICAgICAgICAgICAgLy8gd2hlbiBzb21lb25lIHVzaW5nIHVzZUNvbnRyb2xsZWRTdGF0ZSBjYWxscyBzZXRDb250cm9sbGVkU3RhdGUobXlGdW5jKVxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhbGwgb3VyIHVzZVN0YXRlIHNldFN0YXRlIHdpdGggYSBmdW5jdGlvbiBhcyB3ZWxsIHdoaWNoIGludm9rZXMgbXlGdW5jIGFuZCBjYWxscyBvbkNoYW5nZSB3aXRoIHRoZSB2YWx1ZSBmcm9tIG15RnVuY1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gYW4gdW5jb250cm9sbGVkIHN0YXRlLCB0aGVuIHdlIGFsc28gcmV0dXJuIHRoZSB2YWx1ZSBvZiBteUZ1bmMgd2hpY2ggdG8gc2V0U3RhdGUgbG9va3MgYXMgdGhvdWdoIGl0IHdhcyBqdXN0IGNhbGxlZCB3aXRoIG15RnVuYyBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBqdXN0IHJldHVybiB0aGUgY29udHJvbGxlZCB2YWx1ZSwgd2hpY2ggd29uJ3QgY2F1c2UgYSByZXJlbmRlciBiZWNhdXNlIFJlYWN0IGtub3dzIHRvIGJhaWwgb3V0IHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuY3Rpb24gPSAob2xkVmFsdWUsIC4uLmZ1bmN0aW9uQXJncyk9PntcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJjZXB0ZWRWYWx1ZSA9IHZhbHVlKGlzQ29udHJvbGxlZCA/IGN1cnJlbnRWYWx1ZSA6IG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGVyKGludGVyY2VwdGVkVmFsdWUsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSByZXR1cm4gaW50ZXJjZXB0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZSh1cGRhdGVGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgc2V0U3RhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBvbkNoYW5nZUNhbGxlcih2YWx1ZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzQ29udHJvbGxlZCxcbiAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICBvbkNoYW5nZVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgc2V0VmFsdWVcbiAgICBdO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKipcbiAqIFRha2VzIGEgdmFsdWUgYW5kIGZvcmNlcyBpdCB0byB0aGUgY2xvc2VzdCBtaW4vbWF4IGlmIGl0J3Mgb3V0c2lkZS4gQWxzbyBmb3JjZXMgaXQgdG8gdGhlIGNsb3Nlc3QgdmFsaWQgc3RlcC5cbiAqLyBmdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCh2YWx1ZSwgbWluID0gLUluZmluaXR5LCBtYXggPSBJbmZpbml0eSkge1xuICAgIGxldCBuZXdWYWx1ZSA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzKHZhbHVlLCBtaW4sIG1heCwgc3RlcCkge1xuICAgIG1pbiA9IE51bWJlcihtaW4pO1xuICAgIG1heCA9IE51bWJlcihtYXgpO1xuICAgIGxldCByZW1haW5kZXIgPSAodmFsdWUgLSAoaXNOYU4obWluKSA/IDAgOiBtaW4pKSAlIHN0ZXA7XG4gICAgbGV0IHNuYXBwZWRWYWx1ZSA9IE1hdGguYWJzKHJlbWFpbmRlcikgKiAyID49IHN0ZXAgPyB2YWx1ZSArIE1hdGguc2lnbihyZW1haW5kZXIpICogKHN0ZXAgLSBNYXRoLmFicyhyZW1haW5kZXIpKSA6IHZhbHVlIC0gcmVtYWluZGVyO1xuICAgIGlmICghaXNOYU4obWluKSkge1xuICAgICAgICBpZiAoc25hcHBlZFZhbHVlIDwgbWluKSBzbmFwcGVkVmFsdWUgPSBtaW47XG4gICAgICAgIGVsc2UgaWYgKCFpc05hTihtYXgpICYmIHNuYXBwZWRWYWx1ZSA+IG1heCkgc25hcHBlZFZhbHVlID0gbWluICsgTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIHN0ZXApICogc3RlcDtcbiAgICB9IGVsc2UgaWYgKCFpc05hTihtYXgpICYmIHNuYXBwZWRWYWx1ZSA+IG1heCkgc25hcHBlZFZhbHVlID0gTWF0aC5mbG9vcihtYXggLyBzdGVwKSAqIHN0ZXA7XG4gICAgLy8gY29ycmVjdCBmbG9hdGluZyBwb2ludCBiZWhhdmlvciBieSByb3VuZGluZyB0byBzdGVwIHByZWNpc2lvblxuICAgIGxldCBzdHJpbmcgPSBzdGVwLnRvU3RyaW5nKCk7XG4gICAgbGV0IGluZGV4ID0gc3RyaW5nLmluZGV4T2YoXCIuXCIpO1xuICAgIGxldCBwcmVjaXNpb24gPSBpbmRleCA+PSAwID8gc3RyaW5nLmxlbmd0aCAtIGluZGV4IDogMDtcbiAgICBpZiAocHJlY2lzaW9uID4gMCkge1xuICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgICAgIHNuYXBwZWRWYWx1ZSA9IE1hdGgucm91bmQoc25hcHBlZFZhbHVlICogcG93KSAvIHBvdztcbiAgICB9XG4gICAgcmV0dXJuIHNuYXBwZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYodmFsdWUsIGRpZ2l0cywgYmFzZSA9IDEwKSB7XG4gICAgY29uc3QgcG93ID0gTWF0aC5wb3coYmFzZSwgZGlnaXRzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHBvdykgLyBwb3c7XG59XG5cblxuXG5cbmV4cG9ydCB7JDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUgYXMgdXNlQ29udHJvbGxlZFN0YXRlLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCBhcyBjbGFtcCwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjMgYXMgc25hcFZhbHVlVG9TdGVwLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmIGFzIHRvRml4ZWROdW1iZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */ validate(invalidationContext) {}\n    /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\n   * Returns a copy of the LayoutInfo.\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\n   * Returns a copy of this point.\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Checks if two points are equal.\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\n   * Returns true if this point is the origin.\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nclass $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\n   * The maximum x-coordinate in the rectangle.\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\n   * The maximum y-coordinate in the rectangle.\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\n   * The area of the rectangle.\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\n   * The top left corner of the rectangle.\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\n   * The top right corner of the rectangle.\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\n   * The bottom left corner of the rectangle.\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\n   * The bottom right corner of the rectangle.\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\n   * Returns the union of this Rect and another.\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\n   * Returns a copy of this rectangle.\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\n   * Returns a copy of this size.\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n   * Returns whether this size is equal to another one.\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n   * The total area of the Size.\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n// use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf = typeof window !== \"undefined\" ? window.performance : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nclass $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\n\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) // We are already in a layout effect when this method is called, so relayoutNow is appropriate.\n        this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) // @ts-ignore\n            this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // Animated layout transitions are really simple, thanks to our transaction support.\n        // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (// Uses equals rather than pointEquals so that width/height changes are taken into account\n            !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// If an item has a width of 0, there is no need to remove it from the _visibleViews.\n        // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\n\n\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n\n\n\n\n\n//# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErSTtBQUNuRTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQsMkNBQTJDO0FBQzNDLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0Isd0JBQXdCLG9CQUFvQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQixhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixlQUFlLHVEQUF1RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUpBQWlKO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsNkNBQTZDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4QywyQ0FBZTtBQUM3RCw0Q0FBNEMsMkNBQWU7QUFDM0QsMENBQTBDLDJDQUFlO0FBQ3pELDBDQUEwQywyQ0FBZTtBQUN6RCwwQkFBMEIsMENBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQXNCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSw0Q0FBZ0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsOENBQWtCO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsOENBQWtCO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBa0I7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLNFk7QUFDNVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGZhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3ZpcnR1YWxpemVyL2Rpc3QvaW1wb3J0Lm1qcz9mMjE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU3RhdGUgYXMgJDhEM25yJHVzZVN0YXRlLCB1c2VNZW1vIGFzICQ4RDNuciR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJDhEM25yJHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgYXMgJDhEM25yJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlTGF5b3V0RWZmZWN0IGFzICQ4RDNuciR1c2VMYXlvdXRFZmZlY3R9IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRjNzRjZGE3ZDMxYWYxMjUzJGV4cG9ydCRjODQ2NzFmNDZkNmExY2Ege1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgaW52YWxpZGF0ZSBpbiByZXNwb25zZSB0b1xuICAgKiB2aXNpYmxlIHJlY3RhbmdsZSBjaGFuZ2VzLiBCeSBkZWZhdWx0LCBpdCBvbmx5IGludmFsaWRhdGVzXG4gICAqIHdoZW4gdGhlIGNvbGxlY3Rpb24gdmlldydzIHNpemUgY2hhbmdlcy4gUmV0dXJuIHRydWUgYWx3YXlzXG4gICAqIHRvIG1ha2UgdGhlIGxheW91dCBpbnZhbGlkYXRlIHdoaWxlIHNjcm9sbGluZyAoZS5nLiBzdGlja3kgaGVhZGVycykuXG4gICAqLyBzaG91bGRJbnZhbGlkYXRlKG5ld1JlY3QsIG9sZFJlY3QpIHtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgaW52YWxpZGF0ZSB3aGVuIHRoZSBzaXplIGNoYW5nZXNcbiAgICAgICAgcmV0dXJuIG5ld1JlY3Qud2lkdGggIT09IG9sZFJlY3Qud2lkdGggfHwgbmV3UmVjdC5oZWlnaHQgIT09IG9sZFJlY3QuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIHRoZSBsYXlvdXQgdG8gcGVyZm9ybSBhbnkgcHJlLWNvbXB1dGF0aW9uXG4gICAqIGl0IG5lZWRzIHRvIGluIG9yZGVyIHRvIHByZXBhcmUge0BsaW5rIExheW91dEluZm99cyBmb3IgcmV0cmlldmFsLlxuICAgKiBDYWxsZWQgYnkgdGhlIGNvbGxlY3Rpb24gdmlldyBiZWZvcmUge0BsaW5rIGdldFZpc2libGVMYXlvdXRJbmZvc31cbiAgICogb3Ige0BsaW5rIGdldExheW91dEluZm99IGFyZSBjYWxsZWQuXG4gICAqLyB2YWxpZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KSB7fVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEge0BsaW5rIERyYWdUYXJnZXR9IGRlc2NyaWJpbmcgYSB2aWV3IGF0IHRoZSBnaXZlbiBwb2ludCB0byBiZSBkcmFnZ2VkLlxuICAgKiBSZXR1cm4gYG51bGxgIHRvIGNhbmNlbCB0aGUgZHJhZy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgdmlldyBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIGRyYWcgb2NjdXJyZWQuXG4gICAqLyAvLyBnZXREcmFnVGFyZ2V0KHBvaW50OiBQb2ludCk6IERyYWdUYXJnZXQgfCBudWxsIHtcbiAgICAvLyAgIGxldCB0YXJnZXQgPSB0aGlzLnZpcnR1YWxpemVyLmtleUF0UG9pbnQocG9pbnQpO1xuICAgIC8vICAgaWYgKCF0YXJnZXQpIHtcbiAgICAvLyAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4ge1xuICAgIC8vICAgICB0eXBlOiAnaXRlbScsXG4gICAgLy8gICAgIGtleTogdGFyZ2V0XG4gICAgLy8gICB9O1xuICAgIC8vIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBEcmFnVGFyZ2V0fSBvYmplY3QgZGVzY3JpYmluZyB3aGVyZSBhIGRyb3Agc2hvdWxkIG9jY3VyLiBSZXR1cm4gYG51bGxgXG4gICAqIHRvIHJlamVjdCB0aGUgZHJvcC4gVGhlIGRyb3BwZWQgaXRlbXMgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIHJlc3VsdGluZyB0YXJnZXQuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIGRyb3Agb2NjdXJyZWQuXG4gICAqLyAvLyBnZXREcm9wVGFyZ2V0KHBvaW50OiBQb2ludCk6IERyb3BUYXJnZXQgfCBudWxsIHtcbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnRpbmcgYXR0cmlidXRlcyBmb3IgYW4gYW5pbWF0ZWQgaW5zZXJ0aW9uLlxuICAgKiBUaGUgdmlldyBpcyBhbmltYXRlZCBmcm9tIHRoaXMge0BsaW5rIExheW91dEluZm99IHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkge0BsaW5rIGdldExheW91dEluZm99LlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybnMgaXRzIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0gbGF5b3V0SW5mbyBUaGUgcHJvcG9zZWQgTGF5b3V0SW5mbyBmb3IgdGhpcyB2aWV3LlxuICAgKi8gZ2V0SW5pdGlhbExheW91dEluZm8obGF5b3V0SW5mbykge1xuICAgICAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZGluZyBhdHRyaWJ1dGVzIGZvciBhbiBhbmltYXRlZCByZW1vdmFsLlxuICAgKiBUaGUgdmlldyBpcyBhbmltYXRlZCBmcm9tIHRoZSB7QGxpbmsgTGF5b3V0SW5mb30gcmV0dXJuZWQgYnkge0BsaW5rIGdldExheW91dEluZm99XG4gICAqIHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgaXRzIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0gbGF5b3V0SW5mbyBUaGUgb3JpZ2luYWwgTGF5b3V0SW5mbyBmb3IgdGhpcyB2aWV3LlxuICAgKi8gZ2V0RmluYWxMYXlvdXRJbmZvKGxheW91dEluZm8pIHtcbiAgICAgICAgcmV0dXJuIGxheW91dEluZm87XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBMYXlvdXRJbmZvLlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgbGV0IHJlcyA9IG5ldyAkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSh0aGlzLnR5cGUsIHRoaXMua2V5LCB0aGlzLnJlY3QuY29weSgpKTtcbiAgICAgICAgcmVzLmVzdGltYXRlZFNpemUgPSB0aGlzLmVzdGltYXRlZFNpemU7XG4gICAgICAgIHJlcy5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICByZXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHJlcy5wYXJlbnRLZXkgPSB0aGlzLnBhcmVudEtleTtcbiAgICAgICAgcmVzLmlzU3RpY2t5ID0gdGhpcy5pc1N0aWNreTtcbiAgICAgICAgcmVzLnpJbmRleCA9IHRoaXMuekluZGV4O1xuICAgICAgICByZXMuYWxsb3dPdmVyZmxvdyA9IHRoaXMuYWxsb3dPdmVyZmxvdztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAqIEBwYXJhbSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmlldyB0eXBlLiBTaG91bGQgYmUgYCdpdGVtJ2AgZm9yIGl0ZW0gdmlld3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXIgdHlwZXMgYXJlIHVzZWQgYnkgc3VwcGxlbWVudGFyeSB2aWV3cy5cbiAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGtleSBmb3IgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdGFuZ2xlIGRlc2NyaWJpbmcgdGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoaXMgdmlldy5cbiAgICovIGNvbnN0cnVjdG9yKHR5cGUsIGtleSwgcmVjdCl7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBhcmVudEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjdCA9IHJlY3Q7XG4gICAgICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RpY2t5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy56SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmFsbG93T3ZlcmZsb3cgPSBmYWxzZTtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhIHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb2ludC5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsLlxuICAgKi8gZXF1YWxzKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgdGhlIG9yaWdpbi5cbiAgICovIGlzT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKXtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY2xhc3MgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2Qge1xuICAgIC8qKlxuICAgKiBUaGUgbWF4aW11bSB4LWNvb3JkaW5hdGUgaW4gdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBtYXhYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHktY29vcmRpbmF0ZSBpbiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IG1heFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBhcmVhIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCB0b3BMZWZ0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCB0b3BSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMubWF4WCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBib3R0b21MZWZ0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy54LCB0aGlzLm1heFkpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBib3R0b21SaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMubWF4WCwgdGhpcy5tYXhZKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHJlY3RhbmdsZSBpbnRlcnNlY3RzIGFub3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBpbnRlcnNlY3RzKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHJlY3QueCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCAmJiByZWN0LnkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByZWN0YW5nbGUgZnVsbHkgY29udGFpbnMgYW5vdGhlciByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBjaGVjay5cbiAgICovIGNvbnRhaW5zUmVjdChyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcmVjdC54ICYmIHRoaXMueSA8PSByZWN0LnkgJiYgdGhpcy5tYXhYID49IHJlY3QubWF4WCAmJiB0aGlzLm1heFkgPj0gcmVjdC5tYXhZO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gY2hlY2suXG4gICAqLyBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcG9pbnQueCAmJiB0aGlzLnkgPD0gcG9pbnQueSAmJiB0aGlzLm1heFggPj0gcG9pbnQueCAmJiB0aGlzLm1heFkgPj0gcG9pbnQueTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGNvcm5lciBvZiB0aGlzIHJlY3RhbmdsZSAoZnJvbSB0b3AgdG8gYm90dG9tLCBsZWZ0IHRvIHJpZ2h0KVxuICAgKiB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLCBvciBudWxsIG9mIHRoZSByZWN0YW5nbGVzIGRvIG5vdCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBjaGVjay5cbiAgICovIGdldENvcm5lckluUmVjdChyZWN0KSB7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBbXG4gICAgICAgICAgICBcInRvcExlZnRcIixcbiAgICAgICAgICAgIFwidG9wUmlnaHRcIixcbiAgICAgICAgICAgIFwiYm90dG9tTGVmdFwiLFxuICAgICAgICAgICAgXCJib3R0b21SaWdodFwiXG4gICAgICAgIF0pe1xuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbnNQb2ludCh0aGlzW2tleV0pKSByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlcXVhbHMocmVjdCkge1xuICAgICAgICByZXR1cm4gcmVjdC54ID09PSB0aGlzLnggJiYgcmVjdC55ID09PSB0aGlzLnkgJiYgcmVjdC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJiByZWN0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIHBvaW50RXF1YWxzKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55O1xuICAgIH1cbiAgICBzaXplRXF1YWxzKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IHNpemUud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5pb24gb2YgdGhpcyBSZWN0IGFuZCBhbm90aGVyLlxuICAgKi8gdW5pb24ob3RoZXIpIHtcbiAgICAgICAgbGV0IHggPSBNYXRoLm1pbih0aGlzLngsIG90aGVyLngpO1xuICAgICAgICBsZXQgeSA9IE1hdGgubWluKHRoaXMueSwgb3RoZXIueSk7XG4gICAgICAgIGxldCB3aWR0aCA9IE1hdGgubWF4KHRoaXMubWF4WCwgb3RoZXIubWF4WCkgLSB4O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5tYXhZLCBvdGhlci5tYXhZKSAtIHk7XG4gICAgICAgIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBSZWN0IHdpdGggYW5vdGhlci5cbiAgICogSWYgdGhlIHJlY3RhbmdsZXMgZG8gbm90IGludGVyc2VjdCwgYW4gYWxsIHplcm8gUmVjdCBpcyByZXR1cm5lZC5cbiAgICovIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhvdGhlcikpIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoMCwgMCwgMCwgMCk7XG4gICAgICAgIGxldCB4ID0gTWF0aC5tYXgodGhpcy54LCBvdGhlci54KTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLm1heCh0aGlzLnksIG90aGVyLnkpO1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHgsIHksIE1hdGgubWluKHRoaXMubWF4WCwgb3RoZXIubWF4WCkgLSB4LCBNYXRoLm1pbih0aGlzLm1heFksIG90aGVyLm1heFkpIC0geSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHJlY3RhbmdsZS5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApe1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHNpemUuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHNpemUgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmUuXG4gICAqLyBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgdG90YWwgYXJlYSBvZiB0aGUgU2l6ZS5cbiAgICovIGdldCBhcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDApe1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gbGV0ICRhZDFkOThhYThmMGMzMWI0JHZhciRLRVkgPSAwO1xuY2xhc3MgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEge1xuICAgIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgdmlldyBmb3IgcmV1c2UuIENhbGxlZCBqdXN0IGJlZm9yZSB0aGUgdmlldyBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICovIHByZXBhcmVGb3JSZXVzZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF5b3V0SW5mbyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZpcnR1YWxpemVyKXtcbiAgICAgICAgdGhpcy52aXJ0dWFsaXplciA9IHZpcnR1YWxpemVyO1xuICAgICAgICB0aGlzLmtleSA9ICsrJGFkMWQ5OGFhOGYwYzMxYjQkdmFyJEtFWTtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vLyB1c2UgaGlnaCByZXMgdGltZXIgaWYgYXZhaWxhYmxlXG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcbi8vIEB0cy1pZ25vcmVcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdyA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmICYmICgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5ub3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYud2Via2l0Tm93IHx8ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLm1zTm93IHx8ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLm1vek5vdyk7XG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdyA/ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93LmJpbmQoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYpIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHM7XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYyhiZWdpbiwgZW5kLCBkdXJhdGlvbiwgZWFzZSwgZm4pIHtcbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBsZXQgcmFmX2lkO1xuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIGxldCBzdGFydCA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCk7XG4gICAgICAgIGxldCBkaWZmWCA9IGVuZC54IC0gYmVnaW4ueDtcbiAgICAgICAgbGV0IGRpZmZZID0gZW5kLnkgLSBiZWdpbi55O1xuICAgICAgICByYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gcnVuKHQpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHVzaW5nIGEgaGlnaCByZXMgdGltZXIsIG1ha2Ugc3VyZSB0aW1lc3RhbXAgaXMgbm90IHRoZSBvbGQgZXBvY2gtYmFzZWQgdmFsdWUuXG4gICAgICAgICAgICAvLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA1L3JlcXVlc3RBbmltYXRpb25GcmFtZS1BUEktbm93LXdpdGgtc3ViLW1pbGxpc2Vjb25kLXByZWNpc2lvblxuICAgICAgICAgICAgaWYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcyA9PSBudWxsKSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMgPSB0ID4gMWUxMiAhPT0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUoKSA+IDFlMTI7XG4gICAgICAgICAgICBpZiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzKSB0ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIGxldCBkZWx0YSA9IHQgLSBzdGFydDtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm4oZW5kKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZnJhbWUgY2FsbGJhY2sgYWZ0ZXIgY29tcHV0aW5nIGVhc2VkIHRpbWUgYW5kIGdldCB0aGUgbmV4dCBmcmFtZVxuICAgICAgICAgICAgICAgIGxldCBwcm9jZWVkID0gZm4obmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoYmVnaW4ueCArIGRpZmZYICogZWFzZShkZWx0YSAvIGR1cmF0aW9uKSwgYmVnaW4ueSArIGRpZmZZICogZWFzZShkZWx0YSAvIGR1cmF0aW9uKSkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZWVkICE9PSBmYWxzZSAmJiAhY2FuY2VsZWQpIHJhZl9pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShydW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZl9pZCk7XG4gICAgfTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ3Nzg2MGMxMDZiNGE2YTJlKHQpIHtcbiAgICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ1NzYzNmJiNDNiMWNjYmIwKHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4odCAqIE1hdGguUEkgLyAyKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYSwgYikge1xuICAgIGxldCByZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQga2V5IG9mIGEua2V5cygpKWlmICghYi5oYXMoa2V5KSkgcmVzLmFkZChrZXkpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYWNhZjk2YTI3NDM4MjQ2YihhLCBiKSB7XG4gICAgbGV0IHRvUmVtb3ZlID0gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYSwgYik7XG4gICAgbGV0IHRvQWRkID0gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYiwgYSk7XG4gICAgbGV0IHRvVXBkYXRlID0gbmV3IFNldDtcbiAgICBmb3IgKGxldCBrZXkgb2YgYS5rZXlzKCkpaWYgKGIuaGFzKGtleSkpIHRvVXBkYXRlLmFkZChrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvUmVtb3ZlOiB0b1JlbW92ZSxcbiAgICAgICAgdG9BZGQ6IHRvQWRkLFxuICAgICAgICB0b1VwZGF0ZTogdG9VcGRhdGVcbiAgICB9O1xufVxuZnVuY3Rpb24qICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRjZmMxNDA4OGRmZWZjZTVmKC4uLml0ZXJhdG9ycykge1xuICAgIGZvciAobGV0IGl0ZXJhdG9yIG9mIGl0ZXJhdG9ycyl5aWVsZCogaXRlcmF0b3I7XG59XG5mdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkNjg5N2MyODRiNmY5ZjRkYyhvYmplY3QpIHtcbiAgICBsZXQgcmVzID0ge307XG4gICAgZm9yKGxldCBrZXkgaW4gb2JqZWN0KXJlc1tvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhOGQwZDBjOGQxYzVkZjY0KGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGEpe1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jbGFzcyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2Uge1xuICAgIGFkZFNhbXBsZShzYW1wbGUpIHtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB0aGlzLnZhbHVlICs9IChzYW1wbGUgLSB0aGlzLnZhbHVlKSAvIHRoaXMuY291bnQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICB9XG59XG5jbGFzcyAkMzY0MTkxYjNkZWNmMzY5NyRleHBvcnQkNDQ1NWVlNmFmYjM4ZGNiYiB7XG4gICAgc2V0VmlzaWJsZVJlY3QocmVjdCkge1xuICAgICAgICBsZXQgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lIDwgNTAwKSB7XG4gICAgICAgICAgICB0aGlzLmF2ZXJhZ2VUaW1lLmFkZFNhbXBsZSh0aW1lKTtcbiAgICAgICAgICAgIGlmIChyZWN0LnggIT09IHRoaXMudmlzaWJsZVJlY3QueCAmJiB0aW1lID4gMCkgdGhpcy52ZWxvY2l0eS54ID0gKHJlY3QueCAtIHRoaXMudmlzaWJsZVJlY3QueCkgLyB0aW1lO1xuICAgICAgICAgICAgaWYgKHJlY3QueSAhPT0gdGhpcy52aXNpYmxlUmVjdC55ICYmIHRpbWUgPiAwKSB0aGlzLnZlbG9jaXR5LnkgPSAocmVjdC55IC0gdGhpcy52aXNpYmxlUmVjdC55KSAvIHRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgfVxuICAgIGNvbGxlY3RNZXRyaWNzKCkge1xuICAgICAgICBsZXQgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lIDwgNTAwKSB0aGlzLmF2ZXJhZ2VQZXJmLmFkZFNhbXBsZSh0aW1lKTtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZVJlY3QuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG8gPSBNYXRoLmFicyh0aGlzLnZlbG9jaXR5LnkgKiAodGhpcy5hdmVyYWdlVGltZS52YWx1ZSArIHRoaXMuYXZlcmFnZVBlcmYudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcnNjYW5ZLmFkZFNhbXBsZShvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXNpYmxlUmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvID0gTWF0aC5hYnModGhpcy52ZWxvY2l0eS54ICogKHRoaXMuYXZlcmFnZVRpbWUudmFsdWUgKyB0aGlzLmF2ZXJhZ2VQZXJmLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJzY2FuWC5hZGRTYW1wbGUobyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0T3ZlcnNjYW5uZWRSZWN0KCkge1xuICAgICAgICBsZXQgb3ZlcnNjYW5uZWQgPSB0aGlzLnZpc2libGVSZWN0LmNvcHkoKTtcbiAgICAgICAgbGV0IG92ZXJzY2FuWSA9IE1hdGgucm91bmQoTWF0aC5taW4odGhpcy52aXNpYmxlUmVjdC5oZWlnaHQgKiAyLCB0aGlzLm92ZXJzY2FuWS52YWx1ZSkgLyAxMDApICogMTAwO1xuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eS55ID4gMCkge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueSAtPSBvdmVyc2NhblkgKiAwLjI7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC5oZWlnaHQgKz0gb3ZlcnNjYW5ZICsgb3ZlcnNjYW5ZICogMC4yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueSAtPSBvdmVyc2Nhblk7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC5oZWlnaHQgKz0gb3ZlcnNjYW5ZICsgb3ZlcnNjYW5ZICogMC4yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyc2NhblggPSBNYXRoLnJvdW5kKE1hdGgubWluKHRoaXMudmlzaWJsZVJlY3Qud2lkdGggKiAyLCB0aGlzLm92ZXJzY2FuWC52YWx1ZSkgLyAxMDApICogMTAwO1xuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eS54ID4gMCkge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueCAtPSBvdmVyc2NhblggKiAwLjI7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC53aWR0aCArPSBvdmVyc2NhblggKyBvdmVyc2NhblggKiAwLjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC54IC09IG92ZXJzY2FuWDtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLndpZHRoICs9IG92ZXJzY2FuWCArIG92ZXJzY2FuWCAqIDAuMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcnNjYW5uZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5hdmVyYWdlUGVyZiA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy5hdmVyYWdlVGltZSA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKDUsIDUpO1xuICAgICAgICB0aGlzLm92ZXJzY2FuWCA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy5vdmVyc2NhblkgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKSgpO1xuICAgIH1cbn1cblxuXG5cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkOGUxMzVlNTMxZDhkY2I2NiRleHBvcnQkZmViYzU1NzNjNzVjZWZiMCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbml0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxMYXlvdXRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZpbmFsTGF5b3V0SW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRvUmVtb3ZlID0gbmV3IE1hcCgpO1xuICAgIH1cbn1cblxuXG5jbGFzcyAkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMiB7XG4gICAgX3NldENvbnRlbnRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5fY29udGVudFNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldENvbnRlbnRTaXplKHNpemUpO1xuICAgIH1cbiAgICBfc2V0Q29udGVudE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKShvZmZzZXQueCwgb2Zmc2V0LnksIHRoaXMuX3Zpc2libGVSZWN0LndpZHRoLCB0aGlzLl92aXNpYmxlUmVjdC5oZWlnaHQpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFZpc2libGVSZWN0KHJlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGNvbnRlbnQuXG4gICAqLyBnZXQgY29udGVudFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50U2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgY3VycmVudGx5IHZpc2libGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IHZpc2libGVSZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGN1cnJlbnRseSB2aXNpYmxlIHJlY3RhbmdsZS5cbiAgICovIHNldCB2aXNpYmxlUmVjdChyZWN0KSB7XG4gICAgICAgIHRoaXMuX3NldFZpc2libGVSZWN0KHJlY3QpO1xuICAgIH1cbiAgICBfc2V0VmlzaWJsZVJlY3QocmVjdCwgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX3Zpc2libGVSZWN0O1xuICAgICAgICAvLyBJZ25vcmUgaWYgdGhlIHJlY3RzIGFyZSBlcXVhbFxuICAgICAgICBpZiAocmVjdC5lcXVhbHMoY3VycmVudCkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkT3ZlcnNjYW4pIHRoaXMuX292ZXJzY2FuTWFuYWdlci5zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICAgICAgbGV0IHNob3VsZEludmFsaWRhdGUgPSB0aGlzLmxheW91dCAmJiB0aGlzLmxheW91dC5zaG91bGRJbnZhbGlkYXRlKHJlY3QsIHRoaXMuX3Zpc2libGVSZWN0KTtcbiAgICAgICAgdGhpcy5fcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVJlY3QgPSByZWN0O1xuICAgICAgICBpZiAoc2hvdWxkSW52YWxpZGF0ZSkgLy8gV2UgYXJlIGFscmVhZHkgaW4gYSBsYXlvdXQgZWZmZWN0IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLCBzbyByZWxheW91dE5vdyBpcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgdGhpcy5yZWxheW91dE5vdyh7XG4gICAgICAgICAgICBvZmZzZXRDaGFuZ2VkOiAhcmVjdC5wb2ludEVxdWFscyhjdXJyZW50KSxcbiAgICAgICAgICAgIHNpemVDaGFuZ2VkOiAhcmVjdC5zaXplRXF1YWxzKGN1cnJlbnQpXG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIHRoaXMudXBkYXRlU3Vidmlld3MoZm9yY2VVcGRhdGUpO1xuICAgIH1cbiAgICBnZXQgY29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247XG4gICAgfVxuICAgIHNldCBjb2xsZWN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fc2V0RGF0YShkYXRhKTtcbiAgICB9XG4gICAgX3NldERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdGhpcy5fY29sbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbikgdGhpcy5fcnVuVHJhbnNhY3Rpb24oKCk9PntcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBkYXRhO1xuICAgICAgICB9LCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA+IDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZWxvYWREYXRhKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFJlbG9hZHMgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2UgYW5kIHJlbGF5b3V0cyB0aGUgY29sbGVjdGlvbiB2aWV3LlxuICAgKiBEb2VzIG5vdCBhbmltYXRlIGFueSBjaGFuZ2VzLiBFcXVpdmFsZW50IHRvIHJlLWFzc2lnbmluZyB0aGUgc2FtZSBkYXRhIHNvdXJjZVxuICAgKiB0byB0aGUgY29sbGVjdGlvbiB2aWV3LlxuICAgKi8gcmVsb2FkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5yZWxheW91dCh7XG4gICAgICAgICAgICBjb250ZW50Q2hhbmdlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgKi8gZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24gPyB0aGlzLl9jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSA6IG51bGw7XG4gICAgfVxuICAgIC8qKiBUaGUgc2V0IG9mIHBlcnNpc3RlZCBrZXlzIGFyZSBhbHdheXMgcHJlc2VudCBpbiB0aGUgRE9NLCBldmVuIGlmIG5vdCBjdXJyZW50bHkgaW4gdmlldy4gKi8gZ2V0IHBlcnNpc3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJzaXN0ZWRLZXlzO1xuICAgIH1cbiAgICAvKiogVGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cyBhcmUgYWx3YXlzIHByZXNlbnQgaW4gdGhlIERPTSwgZXZlbiBpZiBub3QgY3VycmVudGx5IGluIHZpZXcuICovIHNldCBwZXJzaXN0ZWRLZXlzKHBlcnNpc3RlZEtleXMpIHtcbiAgICAgICAgaWYgKCEoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGE4ZDBkMGM4ZDFjNWRmNjQpKHBlcnNpc3RlZEtleXMsIHRoaXMuX3BlcnNpc3RlZEtleXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJzaXN0ZWRLZXlzID0gcGVyc2lzdGVkS2V5cztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3Vidmlld3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBrZXksIG9yIGFuIGFuY2VzdG9yLCBpcyBwZXJzaXN0ZWQuICovIGlzUGVyc2lzdGVkS2V5KGtleSkge1xuICAgICAgICAvLyBRdWljayBjaGVjayBpZiB0aGUga2V5IGlzIGRpcmVjdGx5IGluIHRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMuXG4gICAgICAgIGlmICh0aGlzLl9wZXJzaXN0ZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gSWYgbm90LCBjaGVjayBpZiB0aGUga2V5IGlzIGFuIGFuY2VzdG9yIG9mIGFueSBvZiB0aGUgcGVyc2lzdGVkIGtleXMuXG4gICAgICAgIGZvciAobGV0IGsgb2YgdGhpcy5fcGVyc2lzdGVkS2V5cyl3aGlsZShrICE9IG51bGwpe1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGspO1xuICAgICAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSBicmVhaztcbiAgICAgICAgICAgIGsgPSBsYXlvdXRJbmZvLnBhcmVudEtleTtcbiAgICAgICAgICAgIGlmIChrID09PSBrZXkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LlxuICAgKi8gZ2V0IGxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LlxuICAgKi8gc2V0IGxheW91dChsYXlvdXQpIHtcbiAgICAgICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dCwgb3B0aW9uYWxseSB3aXRoIGFuIGFuaW1hdGVkIHRyYW5zaXRpb25cbiAgICogZnJvbSB0aGUgY3VycmVudCBsYXlvdXQgdG8gdGhlIG5ldyBsYXlvdXQuXG4gICAqIEBwYXJhbSBsYXlvdXQgVGhlIGxheW91dCB0byBzd2l0Y2ggdG8uXG4gICAqIEBwYXJhbSBhbmltYXRlZCBXaGV0aGVyIHRvIGFuaW1hdGUgdGhlIGxheW91dCBjaGFuZ2UuXG4gICAqLyBzZXRMYXlvdXQobGF5b3V0LCBhbmltYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChsYXlvdXQgPT09IHRoaXMuX2xheW91dCkgcmV0dXJuO1xuICAgICAgICBsZXQgYXBwbHlMYXlvdXQgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xheW91dCkgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnZpcnR1YWxpemVyID0gbnVsbDtcbiAgICAgICAgICAgIGxheW91dC52aXJ0dWFsaXplciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhbmltYXRlZCkgLy8gQW5pbWF0ZWQgbGF5b3V0IHRyYW5zaXRpb25zIGFyZSByZWFsbHkgc2ltcGxlLCB0aGFua3MgdG8gb3VyIHRyYW5zYWN0aW9uIHN1cHBvcnQuXG4gICAgICAgIC8vIFdlIGp1c3Qgc2V0IHRoZSBsYXlvdXQgaW5zaWRlIGEgdHJhbnNhY3Rpb24gYWN0aW9uLCB3aGljaCBydW5zIGFmdGVyIHRoZSBpbml0aWFsXG4gICAgICAgIC8vIGxheW91dCBpbmZvcyBmb3IgdGhlIGFuaW1hdGlvbiBhcmUgcmV0cmlldmVkIGZyb20gdGhlIHByZXZpb3VzIGxheW91dC4gVGhlbiwgdGhlXG4gICAgICAgIC8vIGZpbmFsIGxheW91dCBpbmZvcyBhcmUgcmV0cmlldmVkIGZyb20gdGhlIG5ldyBsYXlvdXQsIGFuZCBhbmltYXRpb25zIG9jY3VyLlxuICAgICAgICB0aGlzLl9ydW5UcmFuc2FjdGlvbihhcHBseUxheW91dCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXBwbHlMYXlvdXQoKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0UmV1c2VUeXBlKGxheW91dEluZm8sIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGxheW91dEluZm8udHlwZSA9PT0gXCJpdGVtXCIgJiYgY29udGVudCkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLmRlbGVnYXRlLmdldFR5cGUgPyB0aGlzLmRlbGVnYXRlLmdldFR5cGUoY29udGVudCkgOiBcIml0ZW1cIjtcbiAgICAgICAgICAgIGxldCByZXVzZVR5cGUgPSB0eXBlID09PSBcIml0ZW1cIiA/IFwiaXRlbVwiIDogbGF5b3V0SW5mby50eXBlICsgXCJfXCIgKyB0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHJldXNlVHlwZTogcmV1c2VUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBsYXlvdXRJbmZvLnR5cGUsXG4gICAgICAgICAgICByZXVzZVR5cGU6IGxheW91dEluZm8udHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSZXVzYWJsZVZpZXcobGF5b3V0SW5mbykge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuZ2V0SXRlbShsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgIGxldCB7IHJldXNlVHlwZTogcmV1c2VUeXBlIH0gPSB0aGlzLl9nZXRSZXVzZVR5cGUobGF5b3V0SW5mbywgY29udGVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcmV1c2FibGVWaWV3c1tyZXVzZVR5cGVdKSB0aGlzLl9yZXVzYWJsZVZpZXdzW3JldXNlVHlwZV0gPSBbXTtcbiAgICAgICAgbGV0IHJldXNhYmxlID0gdGhpcy5fcmV1c2FibGVWaWV3c1tyZXVzZVR5cGVdO1xuICAgICAgICBsZXQgdmlldyA9IHJldXNhYmxlLmxlbmd0aCA+IDAgPyByZXVzYWJsZS5wb3AoKSA6IG5ldyAoMCwgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEpKHRoaXMpO1xuICAgICAgICB2aWV3LnZpZXdUeXBlID0gcmV1c2VUeXBlO1xuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBsYXlvdXRJbmZvLnJlY3QueCArPSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueDtcbiAgICAgICAgICAgIGxheW91dEluZm8ucmVjdC55ICs9IHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC55O1xuICAgICAgICB9XG4gICAgICAgIHZpZXcubGF5b3V0SW5mbyA9IGxheW91dEluZm87XG4gICAgICAgIHRoaXMuX3JlbmRlclZpZXcodmlldyk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICBfcmVuZGVyVmlldyhyZXVzYWJsZVZpZXcpIHtcbiAgICAgICAgbGV0IHsgdHlwZTogdHlwZSwga2V5OiBrZXkgfSA9IHJldXNhYmxlVmlldy5sYXlvdXRJbmZvO1xuICAgICAgICByZXVzYWJsZVZpZXcuY29udGVudCA9IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgICAgICByZXVzYWJsZVZpZXcucmVuZGVyZWQgPSB0aGlzLl9yZW5kZXJDb250ZW50KHR5cGUsIHJldXNhYmxlVmlldy5jb250ZW50KTtcbiAgICB9XG4gICAgX3JlbmRlckNvbnRlbnQodHlwZSwgY29udGVudCkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fcmVuZGVyZWRDb250ZW50LmdldChjb250ZW50KTtcbiAgICAgICAgaWYgKGNhY2hlZCAhPSBudWxsKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgcmVuZGVyZWQgPSB0aGlzLmRlbGVnYXRlLnJlbmRlclZpZXcodHlwZSwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50KSB0aGlzLl9yZW5kZXJlZENvbnRlbnQuc2V0KGNvbnRlbnQsIHJlbmRlcmVkKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgY3VycmVudGx5IHZpc2libGUgdmlld3MsIGluY2x1ZGluZyBib3RoXG4gICAqIGl0ZW0gdmlld3MgYW5kIHN1cHBsZW1lbnRhcnkgdmlld3MuXG4gICAqLyBnZXQgdmlzaWJsZVZpZXdzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0cyB0aGUgdmlzaWJsZSB2aWV3IGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQga2V5LiBSZXR1cm5zIG51bGwgaWZcbiAgICogdGhlIHZpZXcgaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHZpZXcgdG8gcmV0cmlldmUuXG4gICAqLyBnZXRWaWV3KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHZpc2libGUgdmlld3MgbWF0Y2hpbmcgdGhlIGdpdmVuIHR5cGUuXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB2aWV3IHR5cGUgdG8gZmluZC5cbiAgICovIGdldFZpZXdzT2ZUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVZpZXdzLmZpbHRlcigodik9PnYubGF5b3V0SW5mbyAmJiB2LmxheW91dEluZm8udHlwZSA9PT0gdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBnaXZlbiB2aWV3LiBSZXR1cm5zIG51bGxcbiAgICogaWYgdGhlIHZpZXcgaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxuICAgKi8ga2V5Rm9yVmlldyh2aWV3KSB7XG4gICAgICAgIGlmICh2aWV3ICYmIHZpZXcubGF5b3V0SW5mbykgcmV0dXJuIHZpZXcubGF5b3V0SW5mby5rZXk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgaXRlbSB2aWV3IGN1cnJlbnRseSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqLyBrZXlBdFBvaW50KHBvaW50KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkocG9pbnQueCwgcG9pbnQueSwgMSwgMSk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IHRoaXMubGF5b3V0LmdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KTtcbiAgICAgICAgLy8gTGF5b3V0IG1heSByZXR1cm4gbXVsdGlwbGUgbGF5b3V0IGluZm9zIGluIHRoZSBjYXNlIG9mXG4gICAgICAgIC8vIHBlcnNpc3RlZCBrZXlzLCBzbyBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBhY3R1YWxseSBpbnRlcnNlY3RzLlxuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIGxheW91dEluZm9zKXtcbiAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0cyhyZWN0KSkgcmV0dXJuIGxheW91dEluZm8ua2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2xlYW51cCBmb3Igd2hlbiB0aGUgVmlydHVhbGl6ZXIgd2lsbCBiZSB1bm1vdW50ZWQuXG4gICAqLyB3aWxsVW5tb3VudCgpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVsYXlvdXRSYWYpO1xuICAgIH1cbiAgICAvKipcbiAgICogVHJpZ2dlcnMgYSBsYXlvdXQgaW52YWxpZGF0aW9uLCBhbmQgdXBkYXRlcyB0aGUgdmlzaWJsZSBzdWJ2aWV3cy5cbiAgICovIHJlbGF5b3V0KGNvbnRleHQgPSB7fSkge1xuICAgICAgICAvLyBJZ25vcmUgcmVsYXlvdXRzIHdoaWxlIGFuaW1hdGluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxBbmltYXRpb24gfHwgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IHNjaGVkdWxlZCBhIHJlbGF5b3V0LCBleHRlbmQgdGhlIGludmFsaWRhdGlvblxuICAgICAgICAvLyBjb250ZXh0IHNvIHdlIGNvYWxlc2NlIG11bHRpcGxlIHJlbGF5b3V0cyBpbiB0aGUgc2FtZSBmcmFtZS5cbiAgICAgICAgaWYgKHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIHJlbGF5b3V0IGltbWVkaWF0ZWx5LiBQcmVmZXIge0BsaW5rIHJlbGF5b3V0fSBvdmVyIHRoaXMgbWV0aG9kXG4gICAqIHdoZXJlIHBvc3NpYmxlLCBzaW5jZSBpdCBjb2FsZXNjZXMgbXVsdGlwbGUgbGF5b3V0IHBhc3NlcyBpbiB0aGUgc2FtZSB0aWNrLlxuICAgKi8gcmVsYXlvdXROb3coY29udGV4dCA9IHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgfHwge30pIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVsYXlvdXQsIHNpbmNlIHdlJ3JlIGRvaW5nIGl0IG5vdy5cbiAgICAgICAgaWYgKHRoaXMuX3JlbGF5b3V0UmFmKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZWxheW91dFJhZik7XG4gICAgICAgICAgICB0aGlzLl9yZWxheW91dFJhZiA9IG51bGw7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb3ZpZGVkIGNvbnRleHQgd2l0aCB0aGUgY3VycmVudCBpbnZhbGlkYXRpb25Db250ZXh0IHNpbmNlIHdlIGFyZSBjYW5jZWxsaW5nXG4gICAgICAgICAgICAvLyBhIHNjaGVkdWxlZCByZWxheW91dE5vdyBjYWxsIHRoYXQgaGFzIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgc2V0IGFzIGl0cyBkZWZhdWx0IGNvbnRleHQgYXJnIChyZWxheW91dE5vdygpIGluIHJlbGF5b3V0KVxuICAgICAgICAgICAgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0LFxuICAgICAgICAgICAgICAgIC4uLmNvbnRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIGludmFsaWRhdGlvbiBjb250ZXh0XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBudWxsO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHdlIGRvbid0IGhhdmUgYSBsYXlvdXQgb3IgY29udGVudCwgb3Igd2UgYXJlXG4gICAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgYW4gYW5pbWF0ZWQgc2Nyb2xsIHRyYW5zaXRpb24uXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIXRoaXMuX2NvbGxlY3Rpb24gfHwgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSByZXR1cm47XG4gICAgICAgIGxldCBzY3JvbGxBbmNob3IgPSB0aGlzLl9nZXRTY3JvbGxBbmNob3IoKTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgYmVmb3JlTGF5b3V0IGhvb2ssIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5iZWZvcmVMYXlvdXQgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGxheW91dFxuICAgICAgICB0aGlzLmxheW91dC52YWxpZGF0ZShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fc2V0Q29udGVudFNpemUodGhpcy5sYXlvdXQuZ2V0Q29udGVudFNpemUoKSk7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIGFmdGVyTGF5b3V0IGhvb2ssIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5hZnRlckxheW91dCA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmFmdGVyTGF5b3V0KCk7XG4gICAgICAgIC8vIEFkanVzdCBzY3JvbGwgcG9zaXRpb24gYmFzZWQgb24gc2Nyb2xsIGFuY2hvciwgYW5kIGNvbnN0cmFpbi5cbiAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgY2hhbmdlZCwgc2Nyb2xsIHRvIHRoZSB0b3AuXG4gICAgICAgIGxldCB2aXNpYmxlUmVjdCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgbGV0IHJlc3RvcmVkU2Nyb2xsQW5jaG9yID0gdGhpcy5fcmVzdG9yZVNjcm9sbEFuY2hvcihzY3JvbGxBbmNob3IsIGNvbnRleHQpO1xuICAgICAgICBsZXQgY29udGVudE9mZnNldFggPSBjb250ZXh0LmNvbnRlbnRDaGFuZ2VkID8gMCA6IHJlc3RvcmVkU2Nyb2xsQW5jaG9yLng7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0WSA9IGNvbnRleHQuY29udGVudENoYW5nZWQgPyAwIDogcmVzdG9yZWRTY3JvbGxBbmNob3IueTtcbiAgICAgICAgY29udGVudE9mZnNldFggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmNvbnRlbnRTaXplLndpZHRoIC0gdmlzaWJsZVJlY3Qud2lkdGgsIGNvbnRlbnRPZmZzZXRYKSk7XG4gICAgICAgIGNvbnRlbnRPZmZzZXRZID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5jb250ZW50U2l6ZS5oZWlnaHQgLSB2aXNpYmxlUmVjdC5oZWlnaHQsIGNvbnRlbnRPZmZzZXRZKSk7XG4gICAgICAgIGxldCBoYXNMYXlvdXRVcGRhdGVzID0gZmFsc2U7XG4gICAgICAgIGlmIChjb250ZW50T2Zmc2V0WCAhPT0gdmlzaWJsZVJlY3QueCB8fCBjb250ZW50T2Zmc2V0WSAhPT0gdmlzaWJsZVJlY3QueSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBhbmltYXRlZCByZWxheW91dCwgd2UgZG8gbm90IGltbWVkaWF0ZWx5IHNjcm9sbCBiZWNhdXNlIGl0IHdvdWxkIGJlIGppdHRlcnkuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIG5ldyBjb250ZW50IG9mZnNldHMsIGFuZCBhcHBseSBpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGluZGl2aWR1YWwgY29udGVudCBpdGVtcyBpbnN0ZWFkLiBBdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24sIHdlJ2xsIHJlc2V0IGFuZCBzZXQgdGhlXG4gICAgICAgICAgICAvLyBzY3JvbGwgb2Zmc2V0IGZvciByZWFsLiBUaGlzIGVuc3VyZXMgaml0dGVyLWZyZWUgYW5pbWF0aW9uIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gc3luY1xuICAgICAgICAgICAgLy8gdGhlIHNjcm9sbCBhbmltYXRpb24gYW5kIHRoZSBjb250ZW50IGFuaW1hdGlvbi5cbiAgICAgICAgICAgIGlmIChjb250ZXh0LmFuaW1hdGVkIHx8ICF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54ICs9IHZpc2libGVSZWN0LnggLSBjb250ZW50T2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueSArPSB2aXNpYmxlUmVjdC55IC0gY29udGVudE9mZnNldFk7XG4gICAgICAgICAgICAgICAgaGFzTGF5b3V0VXBkYXRlcyA9IHRoaXMudXBkYXRlU3Vidmlld3MoY29udGV4dC5jb250ZW50Q2hhbmdlZCk7XG4gICAgICAgICAgICB9IGVsc2UgdGhpcy5fc2V0Q29udGVudE9mZnNldChuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKShjb250ZW50T2Zmc2V0WCwgY29udGVudE9mZnNldFkpKTtcbiAgICAgICAgfSBlbHNlIGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGNvbnRleHQuY29udGVudENoYW5nZWQpO1xuICAgICAgICAvLyBBcHBseSBsYXlvdXQgaW5mb3MsIHVubGVzcyB0aGlzIGlzIGNvbWluZyBmcm9tIGFuIGFuaW1hdGVkIHRyYW5zYWN0aW9uXG4gICAgICAgIGlmICghKGNvbnRleHQudHJhbnNhY3Rpb24gJiYgY29udGV4dC5hbmltYXRlZCkpIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgYW5pbWF0aW9ucywgYW5kIGFwcGx5IHRoZSBhZnRlckFuaW1hdGlvbiBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAoY29udGV4dC5hbmltYXRlZCAmJiBoYXNMYXlvdXRVcGRhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVUcmFuc2l0aW9ucygpO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVUcmFuc2l0aW9ucygpO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHNjcm9sbCBwb3NpdGlvbiBhZnRlciBhbmltYXRpb25zIChzZWUgYWJvdmUgY29tbWVudCkuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNvbnRlbnQgb2Zmc2V0IHRvIHNjcm9sbCB0bywgdGFraW5nIF9hbmltYXRlZENvbnRlbnRPZmZzZXQgaW50byBhY2NvdW50LlxuICAgICAgICAgICAgICAgICAgICBsZXQgeyB4OiB4LCB5OiB5IH0gPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQobmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoeCwgeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24gPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckFuaW1hdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgYW5pbWF0aW9uIHRha2VzIHNsaWdodGx5IGxvbmdlciB0aGFuIGV4cGVjdGVkLlxuICAgICAgICAgICAgc2V0VGltZW91dChkb25lLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiArIDEwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24gPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckFuaW1hdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ29ycmVjdHMgRE9NIG9yZGVyIG9mIHZpc2libGUgdmlld3MgdG8gbWF0Y2ggaXRlbSBvcmRlciBvZiBjb2xsZWN0aW9uLlxuICAgKi8gX2NvcnJlY3RJdGVtT3JkZXIoKSB7XG4gICAgICAgIC8vIERlZmVyIHVudGlsIGFmdGVyIHNjcm9sbGluZyBhbmQgYW5pbWF0ZWQgdHJhbnNhY3Rpb25zIGFyZSBjb21wbGV0ZVxuICAgICAgICBpZiAodGhpcy5faXNTY3JvbGxpbmcgfHwgdGhpcy5fdHJhbnNhY3Rpb24pIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcy5rZXlzKCkpe1xuICAgICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLl92aXNpYmxlVmlld3MuZ2V0KGtleSk7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5kZWxldGUodmlldyk7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5hZGQodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuYWJsZVRyYW5zaXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBfZGlzYWJsZVRyYW5zaXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmVuZEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgX2dldFNjcm9sbEFuY2hvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHZpc2libGVSZWN0ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICAvLyBBc2sgdGhlIGRlbGVnYXRlIHRvIHByb3ZpZGUgYSBzY3JvbGwgYW5jaG9yLCBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5nZXRTY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmRlbGVnYXRlLmdldFNjcm9sbEFuY2hvcih2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgY29ybmVyID0gbGF5b3V0SW5mby5yZWN0LmdldENvcm5lckluUmVjdCh2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcm5lcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gbGF5b3V0SW5mby5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsYXlvdXRJbmZvLnJlY3RbY29ybmVyXS55IC0gdmlzaWJsZVJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBhbmNob3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBpZiBpdCBpcyBhdCB0aGUgdG9wXG4gICAgICAgIGlmICh2aXNpYmxlUmVjdC55ID09PSAwICYmICF0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3ApIHJldHVybiBudWxsO1xuICAgICAgICAvLyBGaW5kIGEgdmlldyB3aXRoIGEgdmlzaWJsZSBjb3JuZXIgdGhhdCBoYXMgdGhlIHNtYWxsZXN0IGRpc3RhbmNlIHRvIHRoZSB0b3Agb2YgdGhlIGNvbGxlY3Rpb24gdmlld1xuICAgICAgICBsZXQgY29ybmVyQW5jaG9yID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmlld10gb2YgdGhpcy5fdmlzaWJsZVZpZXdzKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKGxheW91dEluZm8gJiYgbGF5b3V0SW5mby5yZWN0LmFyZWEgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lciA9IGxheW91dEluZm8ucmVjdC5nZXRDb3JuZXJJblJlY3QodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGxheW91dEluZm8ucmVjdFtjb3JuZXJdLnkgLSB2aXNpYmxlUmVjdC55O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvcm5lckFuY2hvciB8fCBvZmZzZXQgPCBjb3JuZXJBbmNob3Iub2Zmc2V0KSBjb3JuZXJBbmNob3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3JuZXJBbmNob3I7XG4gICAgfVxuICAgIF9yZXN0b3JlU2Nyb2xsQW5jaG9yKHNjcm9sbEFuY2hvciwgY29udGV4dCkge1xuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgaWYgKHNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgdmFyIF9jb250ZXh0X3RyYW5zYWN0aW9uO1xuICAgICAgICAgICAgbGV0IGZpbmFsQW5jaG9yID0gKChfY29udGV4dF90cmFuc2FjdGlvbiA9IGNvbnRleHQudHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9jb250ZXh0X3RyYW5zYWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29udGV4dF90cmFuc2FjdGlvbi5hbmltYXRlZCkgPyBjb250ZXh0LnRyYW5zYWN0aW9uLmZpbmFsTWFwLmdldChzY3JvbGxBbmNob3Iua2V5KSA6IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oc2Nyb2xsQW5jaG9yLmxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgIGlmIChmaW5hbEFuY2hvcikge1xuICAgICAgICAgICAgICAgIGxldCBhZGp1c3RtZW50ID0gZmluYWxBbmNob3IucmVjdFtzY3JvbGxBbmNob3IuY29ybmVyXS55IC0gY29udGVudE9mZnNldC55IC0gc2Nyb2xsQW5jaG9yLm9mZnNldDtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0LnkgKz0gYWRqdXN0bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudE9mZnNldDtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZVJlY3QoKSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy52aXNpYmxlUmVjdDtcbiAgICAgICAgbGV0IHggPSB2LnggLSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueDtcbiAgICAgICAgbGV0IHkgPSB2LnkgLSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueTtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKHgsIHksIHYud2lkdGgsIHYuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxheW91dEluZm9zKCkge1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuc2hvdWxkT3ZlcnNjYW4gPyB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuZ2V0T3ZlcnNjYW5uZWRSZWN0KCkgOiB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcyA9IHRoaXMuX2dldExheW91dEluZm9NYXAocmVjdCk7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3M7XG4gICAgfVxuICAgIF9nZXRMYXlvdXRJbmZvTWFwKHJlY3QsIGNvcHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mb3MgPSB0aGlzLmxheW91dC5nZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCk7XG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwO1xuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIGxheW91dEluZm9zKXtcbiAgICAgICAgICAgIGlmIChjb3B5KSBsYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBtYXAuc2V0KGxheW91dEluZm8ua2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB1cGRhdGVTdWJ2aWV3cyhmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29sbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgdmlzaWJsZUxheW91dEluZm9zID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3MoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRseVZpc2libGUgPSB0aGlzLl92aXNpYmxlVmlld3M7XG4gICAgICAgIGxldCB0b0FkZCwgdG9SZW1vdmUsIHRvVXBkYXRlO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZm9yY2UgdXBkYXRlLCByZW1vdmUgYW5kIHJlLWFkZCBhbGwgdmlld3MuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZmluZCBhbmQgdXBkYXRlIHRoZSBkaWZmLlxuICAgICAgICBpZiAoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHRvQWRkID0gdmlzaWJsZUxheW91dEluZm9zO1xuICAgICAgICAgICAgdG9SZW1vdmUgPSBjdXJyZW50bHlWaXNpYmxlO1xuICAgICAgICAgICAgdG9VcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAoeyB0b0FkZDogdG9BZGQsIHRvUmVtb3ZlOiB0b1JlbW92ZSwgdG9VcGRhdGU6IHRvVXBkYXRlIH0gPSAoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIpKGN1cnJlbnRseVZpc2libGUsIHZpc2libGVMYXlvdXRJbmZvcykpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvVXBkYXRlKXtcbiAgICAgICAgICAgICAgICBsZXQgdmlldyA9IGN1cnJlbnRseVZpc2libGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3IHx8ICF2aWV3LmxheW91dEluZm8pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5nZXRJdGVtKHZpc2libGVMYXlvdXRJbmZvcy5nZXQoa2V5KS5rZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmNvbnRlbnQgPT09IGl0ZW0pIHRvVXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmlldyB0eXBlIGNoYW5nZXMsIGRlbGV0ZSBhbmQgcmVjcmVhdGUgdGhlIHZpZXcgaW5zdGVhZCBvZiB1cGRhdGluZ1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyByZXVzZVR5cGU6IHJldXNlVHlwZSB9ID0gdGhpcy5fZ2V0UmV1c2VUeXBlKHZpZXcubGF5b3V0SW5mbywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3LnZpZXdUeXBlICE9PSByZXVzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BZGQuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIGlmIHRoZSBzZXRzIGFyZSBlcXVhbFxuICAgICAgICAgICAgaWYgKHRvQWRkLnNpemUgPT09IDAgJiYgdG9SZW1vdmUuc2l6ZSA9PT0gMCAmJiB0b1VwZGF0ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB0aGlzLl9hcHBseUxheW91dEluZm9zKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWNrIHZpZXdzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuIFRoZXkgYXJlIG5vdCByZW1vdmVkIGZyb21cbiAgICAgICAgLy8gdGhlIERPTSBpbW1lZGlhdGVseSwgc2luY2Ugd2UgbWF5IHJldXNlIGFuZCBuZWVkIHRvIHJlLWluc2VydFxuICAgICAgICAvLyB0aGVtIGJhY2sgaW50byB0aGUgRE9NIGFueXdheS5cbiAgICAgICAgbGV0IHJlbW92ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b1JlbW92ZS5rZXlzKCkpe1xuICAgICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLl92aXNpYmxlVmlld3MuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHJlbW92ZWQuYWRkKHZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIHRyYW5zYWN0aW9uLCB3YWl0IHVudGlsIHRoZSBlbmRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgYW5pbWF0aW9ucyB0byByZW1vdmUgdGhlIHZpZXdzIGZyb20gdGhlIERPTS4gQWxzbyBtZWFuc1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IHJldXNlIHRob3NlIHZpZXdzIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUuc2V0KGtleSwgdmlldyk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLnJldXNlVmlldyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9BZGQua2V5cygpKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdmlzaWJsZUxheW91dEluZm9zLmdldChrZXkpO1xuICAgICAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHRyYW5zYWN0aW9uLCBhbmQgYSBsYXlvdXQgY2hhbmdlIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgYW5pbWF0aW9ucyBzdWNoIHRoYXQgYSB2aWV3IHRoYXQgd2FzIGdvaW5nXG4gICAgICAgICAgICAvLyB0byBiZSByZW1vdmVkIGlzIG5vdyBub3QsIHdlIGRvbid0IGNyZWF0ZSBhIG5ldyB2aWV3XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgb2xkIG9uZSBpcyBzdGlsbCBpbiB0aGUgRE9NLCBtYXJrZWQgYXMgdG9SZW1vdmUuXG4gICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0cmFuc2FjdGlvbiwgZ2V0IGluaXRpYWwgbGF5b3V0IGF0dHJpYnV0ZXMgZm9yIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uaGFzKGtleSkpIGxheW91dEluZm8gPSB0aGlzLl90cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgb3IgcmV1c2UgYSB2aWV3IGZvciB0aGlzIHJvd1xuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLmdldFJldXNhYmxlVmlldyhsYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZpZXcgdG8gdGhlIERPTSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJlbW92ZWQuaGFzKHZpZXcpKSB0aGlzLl9jaGlsZHJlbi5hZGQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3Muc2V0KGtleSwgdmlldyk7XG4gICAgICAgICAgICByZW1vdmVkLmRlbGV0ZSh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9VcGRhdGUpe1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBjdXJyZW50bHlWaXNpYmxlLmdldChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVmlldyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlbWFpbmluZyByb3dzIHRvIGRlbGV0ZSBmcm9tIHRoZSBET01cbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikgdGhpcy5yZW1vdmVWaWV3cyhyZW1vdmVkKTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEl0ZW1PcmRlcigpO1xuICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgICAgICBsZXQgaGFzTGF5b3V0VXBkYXRlcyA9IHRoaXMuX3RyYW5zYWN0aW9uICYmICh0b0FkZC5zaXplID4gMCB8fCB0b1JlbW92ZS5zaXplID4gMCB8fCB0aGlzLl9oYXNMYXlvdXRVcGRhdGVzKCkpO1xuICAgICAgICBpZiAoaGFzTGF5b3V0VXBkYXRlcykgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHRyYW5zYWN0aW9uLCBhcHBseSBhbmltYXRpb25zIHRvIHZpc2libGUgdmlld3NcbiAgICAgICAgICAgIC8vIGFuZCBcInRvIGJlIHJlbW92ZWRcIiB2aWV3cywgd2hpY2ggYW5pbWF0ZSBvZmYgc2NyZWVuLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFzTGF5b3V0VXBkYXRlcztcbiAgICB9XG4gICAgYWZ0ZXJSZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvblF1ZXVlLmxlbmd0aCA+IDApIHRoaXMuX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQpIHRoaXMucmVsYXlvdXROb3coKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkT3ZlcnNjYW4pIHRoaXMuX292ZXJzY2FuTWFuYWdlci5jb2xsZWN0TWV0cmljcygpO1xuICAgIH1cbiAgICBfZmx1c2hWaXNpYmxlVmlld3MoKSB7XG4gICAgICAgIC8vIENvbGxlY3Rpb25WaXJ0dWFsaXplciBkZWFscyB3aXRoIGEgZmxhdHRlbmVkIHNldCBvZiBMYXlvdXRJbmZvcywgYnV0IHRoZXkgY2FuIHJlcHJlc2VudCBoZWlyYXJjaHlcbiAgICAgICAgLy8gYnkgcmVmZXJlbmNpbmcgYSBwYXJlbnRLZXkuIEp1c3QgYmVmb3JlIHJlbmRlcmluZyB0aGUgdmlzaWJsZSB2aWV3cywgd2UgcmVidWlsZCB0aGlzIGhlaXJhcmNoeVxuICAgICAgICAvLyBieSBjcmVhdGluZyBhIG1hcHBpbmcgb2Ygdmlld3MgYnkgcGFyZW50IGtleSBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aGUgZGVsZWdhdGUncyByZW5kZXJXcmFwcGVyXG4gICAgICAgIC8vIG1ldGhvZCB0byBidWlsZCB0aGUgZmluYWwgdHJlZS5cbiAgICAgICAgbGV0IHZpZXdzQnlQYXJlbnRLZXkgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX2NoaWxkcmVuKXtcbiAgICAgICAgICAgIHZhciBfdmlld19sYXlvdXRJbmZvLCBfdmlld3NCeVBhcmVudEtleV9nZXQsIF92aWV3X2xheW91dEluZm8xLCBfdmlld19sYXlvdXRJbmZvMiwgX3ZpZXdfbGF5b3V0SW5mbzM7XG4gICAgICAgICAgICBpZiAoKChfdmlld19sYXlvdXRJbmZvID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvLnBhcmVudEtleSkgIT0gbnVsbCAmJiAhdmlld3NCeVBhcmVudEtleS5oYXModmlldy5sYXlvdXRJbmZvLnBhcmVudEtleSkpIHZpZXdzQnlQYXJlbnRLZXkuc2V0KHZpZXcubGF5b3V0SW5mby5wYXJlbnRLZXksIFtdKTtcbiAgICAgICAgICAgIChfdmlld3NCeVBhcmVudEtleV9nZXQgPSB2aWV3c0J5UGFyZW50S2V5LmdldCgoX3ZpZXdfbGF5b3V0SW5mbzEgPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvMS5wYXJlbnRLZXkpKSA9PT0gbnVsbCB8fCBfdmlld3NCeVBhcmVudEtleV9nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3c0J5UGFyZW50S2V5X2dldC5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgaWYgKCF2aWV3c0J5UGFyZW50S2V5LmhhcygoX3ZpZXdfbGF5b3V0SW5mbzIgPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvMi5rZXkpKSB2aWV3c0J5UGFyZW50S2V5LnNldCgoX3ZpZXdfbGF5b3V0SW5mbzMgPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvMy5rZXksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVpbGRUcmVlID0gKHBhcmVudCwgdmlld3MpPT52aWV3cy5tYXAoKHZpZXcpPT57XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gdmlld3NCeVBhcmVudEtleS5nZXQodmlldy5sYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVuZGVyV3JhcHBlcihwYXJlbnQsIHZpZXcsIGNoaWxkcmVuLCAoY2hpbGRWaWV3cyk9PmJ1aWxkVHJlZSh2aWV3LCBjaGlsZFZpZXdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gYnVpbGRUcmVlKG51bGwsIHZpZXdzQnlQYXJlbnRLZXkuZ2V0KG51bGwpKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRWaXNpYmxlVmlld3MoY2hpbGRyZW4pO1xuICAgIH1cbiAgICBfYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pIHtcbiAgICAgICAgaWYgKHZpZXcubGF5b3V0SW5mbyA9PT0gbGF5b3V0SW5mbykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2aWV3LmxheW91dEluZm8gPSBsYXlvdXRJbmZvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2FwcGx5TGF5b3V0SW5mb3MoKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEFwcGx5IGxheW91dCBpbmZvcyB0byB2aXNpYmxlIHZpZXdzXG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdmlzaWJsZVZpZXdzLnZhbHVlcygpKXtcbiAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICBpZiAoKGN1ciA9PT0gbnVsbCB8fCBjdXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1ci5rZXkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oY3VyLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSkgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgZmluYWwgbGF5b3V0IGluZm9zIGZvciB2aWV3cyB0aGF0IHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUudmFsdWVzKCkpe1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICAgICAgaWYgKChjdXIgPT09IG51bGwgfHwgY3VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXIua2V5KSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSkgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl90cmFuc2FjdGlvbi5yZW1vdmVkLnZhbHVlcygpKXtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5fdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLmdldChjdXIua2V5KSB8fCBjdXI7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldEZpbmFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvLmNvcHkoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSkgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgfVxuICAgIF9oYXNMYXlvdXRVcGRhdGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdmlzaWJsZVZpZXdzLnZhbHVlcygpKXtcbiAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICBpZiAoIWN1cikgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oY3VyLmtleSk7XG4gICAgICAgICAgICBpZiAoLy8gVXNlcyBlcXVhbHMgcmF0aGVyIHRoYW4gcG9pbnRFcXVhbHMgc28gdGhhdCB3aWR0aC9oZWlnaHQgY2hhbmdlcyBhcmUgdGFrZW4gaW50byBhY2NvdW50XG4gICAgICAgICAgICAhY3VyLnJlY3QuZXF1YWxzKGxheW91dEluZm8ucmVjdCkgfHwgY3VyLm9wYWNpdHkgIT09IGxheW91dEluZm8ub3BhY2l0eSB8fCBjdXIudHJhbnNmb3JtICE9PSBsYXlvdXRJbmZvLnRyYW5zZm9ybSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXVzZVZpZXcodmlldykge1xuICAgICAgICB2aWV3LnByZXBhcmVGb3JSZXVzZSgpO1xuICAgICAgICB0aGlzLl9yZXVzYWJsZVZpZXdzW3ZpZXcudmlld1R5cGVdLnB1c2godmlldyk7XG4gICAgfVxuICAgIHJlbW92ZVZpZXdzKHRvUmVtb3ZlKSB7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdG9SZW1vdmUpdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpIHtcbiAgICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGJlIGFibGUgdG8gaW52YWxpZGF0ZSBhIHNpbmdsZSBpbmRleCBwYXRoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCF0aGlzLmxheW91dC51cGRhdGVJdGVtU2l6ZSkgcmV0dXJuO1xuICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGN1cnJlbnRseSBhbmltYXRpbmcsIGFkZCB0aGUgdXBkYXRlXG4gICAgICAgIC8vIHRvIGEgcXVldWUgdG8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZS5zZXQoa2V5LCBzaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5sYXlvdXQudXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHRoaXMucmVsYXlvdXQoKTtcbiAgICB9XG4gICAgc3RhcnRTY3JvbGxpbmcoKSB7XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5kU2Nyb2xsaW5nKCkge1xuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XG4gICAgICAgIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgfVxuICAgIF9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFuaW1hdGVkIGNvbnRlbnQgb2Zmc2V0IG9mIHN1YnZpZXdzLiBTZWUgY29tbWVudCBpbiByZWxheW91dE5vdyBmb3IgZGV0YWlscy5cbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUxheW91dEluZm9zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFNjcm9sbHMgdGhlIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4ga2V5IGludG8gdmlldywgb3B0aW9uYWxseSB3aXRoIGFuIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHNjcm9sbCBpbnRvIHZpZXcuXG4gICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBhbmltYXRpb24uXG4gICAqLyBzY3JvbGxUb0l0ZW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGtleSBjYW4gYmUgMCwgc28gY2hlY2sgaWYgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICBpZiAoIWxheW91dEluZm8pIHJldHVybjtcbiAgICAgICAgbGV0IHsgZHVyYXRpb246IGR1cmF0aW9uID0gMzAwLCBzaG91bGRTY3JvbGxYOiBzaG91bGRTY3JvbGxYID0gdHJ1ZSwgc2hvdWxkU2Nyb2xsWTogc2hvdWxkU2Nyb2xsWSA9IHRydWUsIG9mZnNldFg6IG9mZnNldFggPSAwLCBvZmZzZXRZOiBvZmZzZXRZID0gMCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHggPSB0aGlzLnZpc2libGVSZWN0Lng7XG4gICAgICAgIGxldCB5ID0gdGhpcy52aXNpYmxlUmVjdC55O1xuICAgICAgICBsZXQgbWluWCA9IGxheW91dEluZm8ucmVjdC54IC0gb2Zmc2V0WDtcbiAgICAgICAgbGV0IG1pblkgPSBsYXlvdXRJbmZvLnJlY3QueSAtIG9mZnNldFk7XG4gICAgICAgIGxldCBtYXhYID0geCArIHRoaXMudmlzaWJsZVJlY3Qud2lkdGg7XG4gICAgICAgIGxldCBtYXhZID0geSArIHRoaXMudmlzaWJsZVJlY3QuaGVpZ2h0O1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsWCkge1xuICAgICAgICAgICAgaWYgKG1pblggPD0geCB8fCBtYXhYID09PSAwKSB4ID0gbWluWDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheW91dEluZm8ucmVjdC5tYXhYID4gbWF4WCkgeCArPSBsYXlvdXRJbmZvLnJlY3QubWF4WCAtIG1heFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFkpIHtcbiAgICAgICAgICAgIGlmIChtaW5ZIDw9IHkgfHwgbWF4WSA9PT0gMCkgeSA9IG1pblk7XG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRJbmZvLnJlY3QubWF4WSA+IG1heFkpIHkgKz0gbGF5b3V0SW5mby5yZWN0Lm1heFkgLSBtYXhZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvKG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHgsIHkpLCBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhbiBhbmltYXRlZCBzY3JvbGwgdG8gdGhlIGdpdmVuIG9mZnNldC5cbiAgICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gc2Nyb2xsIHRvLlxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICovIHNjcm9sbFRvKG9mZnNldCwgZHVyYXRpb24gPSAzMDApIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IHNjcm9sbCBhbmltYXRpb25cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGNvbnRlbnQgb2Zmc2V0IHN5bmNocm9ub3VzbHkgaWYgdGhlIGR1cmF0aW9uIGlzIHplcm9cbiAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDAgfHwgdGhpcy52aXNpYmxlUmVjdC5wb2ludEVxdWFscyhvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFNjcm9sbGluZygpO1xuICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSAoMCwgJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JGRjMGI2MzcyMDc4ODA5MGMpKHRoaXMudmlzaWJsZVJlY3QsIG9mZnNldCwgZHVyYXRpb24sICgwLCAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNTc2MzZiYjQzYjFjY2JiMCksIChvZmZzZXQpPT57XG4gICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24udGhlbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdmlldyBzaXplIHVwZGF0ZXMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlld3MgdGhhdCBhcmUgc3RpbGwgdmlzaWJsZSB3aWxsIGJlIGFjdHVhbGx5IHVwZGF0ZWQuXG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCBzaXplXSBvZiB0aGlzLl9zaXplVXBkYXRlUXVldWUpdGhpcy51cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnJlbGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5lbmRTY3JvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxBbmltYXRpb247XG4gICAgfVxuICAgIF9ydW5UcmFuc2FjdGlvbihhY3Rpb24sIGFuaW1hdGVkKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbikgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICB0aGlzLl9lbmRUcmFuc2FjdGlvbihhbmltYXRlZCk7XG4gICAgfVxuICAgIF9zdGFydFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX25leHRUcmFuc2FjdGlvbikgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbmV3ICgwLCAkOGUxMzVlNTMxZDhkY2I2NiRleHBvcnQkZmViYzU1NzNjNzVjZWZiMCk7XG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbi5sZXZlbCsrO1xuICAgIH1cbiAgICBfZW5kVHJhbnNhY3Rpb24oYW5pbWF0ZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gU2F2ZSB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYW5pbWF0ZWQuXG4gICAgICAgIGlmIChhbmltYXRlZCAhPSBudWxsKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPSBhbmltYXRlZDtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIGxldmVsIDAsIHdlIGFyZSBzdGlsbCBpbiBhXG4gICAgICAgIC8vIG5lc3RlZCB0cmFuc2FjdGlvbi4gV2FpdCBmb3IgdGhlIHBhcmVudCB0byBlbmQuXG4gICAgICAgIGlmICgtLXRoaXMuX25leHRUcmFuc2FjdGlvbi5sZXZlbCA+IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBmb3IgZW1wdHkgdHJhbnNhY3Rpb25zXG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBhbmltYXRpb25zIHRvIHRydWVcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbi5hbmltYXRlZCA9PSBudWxsKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBFbnF1ZXVlIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvblF1ZXVlLnB1c2godGhpcy5fbmV4dFRyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gaXMgYW5pbWF0aW5nLCB3YWl0IHVudGlsIHRoZSBlbmRcbiAgICAgICAgLy8gdG8gcHJvY2VzcyB0aGUgbmV4dCB0cmFuc2FjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uIHx8IHRoaXMuX3Njcm9sbEFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuX3RyYW5zYWN0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHQpIHRoaXMuX3BlcmZvcm1UcmFuc2FjdGlvbihuZXh0KTtcbiAgICB9XG4gICAgX2dldENvbnRlbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkoMCwgMCwgdGhpcy5jb250ZW50U2l6ZS53aWR0aCwgdGhpcy5jb250ZW50U2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgICBfcGVyZm9ybVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMucmVsYXlvdXROb3coe1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgYW5pbWF0ZWQ6IHRyYW5zYWN0aW9uLmFuaW1hdGVkLFxuICAgICAgICAgICAgYmVmb3JlTGF5b3V0OiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5pdGlhbCBsYXlvdXQgaW5mb3MgZm9yIGFsbCB2aWV3cyBiZWZvcmUgdGhlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4gZmlndXJlIG91dCB3aGljaCB2aWV3cyB0byBhZGQgYW5kIHJlbW92ZS5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uYW5pbWF0ZWQpIHRyYW5zYWN0aW9uLmluaXRpYWxNYXAgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHRoaXMuX2dldENvbnRlbnRSZWN0KCksIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBhY3Rpb25zIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgdHJhbnNhY3Rpb24uYWN0aW9ucylhY3Rpb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckxheW91dDogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIGxheW91dCBpbmZvcyBhZnRlciB0aGUgdXBkYXRlc1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5hbmltYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5maW5hbE1hcCA9IHRoaXMuX2dldExheW91dEluZm9NYXAodGhpcy5fZ2V0Q29udGVudFJlY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwVHJhbnNhY3Rpb25BbmltYXRpb25zKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyQW5pbWF0aW9uOiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbmQgcmV1c2Ugdmlld3Mgd2hlbiBhbmltYXRpb25zIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvUmVtb3ZlLnNpemUgPiAwIHx8IHRyYW5zYWN0aW9uLnJlbW92ZWQuc2l6ZSA+IDApIGZvciAobGV0IHZpZXcgb2YgKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRjZmMxNDA4OGRmZWZjZTVmKSh0cmFuc2FjdGlvbi50b1JlbW92ZS52YWx1ZXMoKSwgdHJhbnNhY3Rpb24ucmVtb3ZlZC52YWx1ZXMoKSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5kZWxldGUodmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV1c2VWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIERPTSBvcmRlciBpcyBjb3JyZWN0IGZvciBhY2Nlc3NpYmlsaXR5IGFmdGVyIGFuaW1hdGlvbnMgYXJlIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgdGhpcy5fY29ycmVjdEl0ZW1PcmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zZXR1cFRyYW5zYWN0aW9uQW5pbWF0aW9ucyh0cmFuc2FjdGlvbikge1xuICAgICAgICBsZXQgeyBpbml0aWFsTWFwOiBpbml0aWFsTWFwLCBmaW5hbE1hcDogZmluYWxNYXAgfSA9IHRyYW5zYWN0aW9uO1xuICAgICAgICAvLyBTdG9yZSBpbml0aWFsIGFuZCBmaW5hbCBsYXlvdXQgaW5mb3MgZm9yIGFuaW1hdGlvbnNcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbGF5b3V0SW5mb10gb2YgaW5pdGlhbE1hcClpZiAoZmluYWxNYXAuaGFzKGtleSkpIC8vIFN0b3JlIHRoZSBpbml0aWFsIGxheW91dCBpbmZvIGZvciB1c2UgZHVyaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgIHRyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLnNldChrZXksIGxheW91dEluZm8pO1xuICAgICAgICBlbHNlIC8vIFRoaXMgdmlldyB3YXMgcmVtb3ZlZC4gU3RvcmUgdGhlIGxheW91dCBpbmZvIGZvciB1c2VcbiAgICAgICAgLy8gaW4gTGF5b3V0I2dldEZpbmFsTGF5b3V0SW5mbyBkdXJpbmcgYW5pbWF0aW9ucy5cbiAgICAgICAgdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLnNldChsYXlvdXRJbmZvLmtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgIC8vIEdldCBpbml0aWFsIGxheW91dCBpbmZvcyBmb3Igdmlld3MgdGhhdCB3ZXJlIGFkZGVkXG4gICAgICAgIGZvciAobGV0IFtrZXksIGxheW91dEluZm9dIG9mIGZpbmFsTWFwKWlmICghaW5pdGlhbE1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgbGV0IGluaXRpYWxMYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0SW5pdGlhbExheW91dEluZm8obGF5b3V0SW5mby5jb3B5KCkpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uc2V0KGtleSwgaW5pdGlhbExheW91dEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggdmlld3Mgd2VyZSByZW1vdmVkLlxuICAgICAgICBmb3IgKGxldCBba2V5LCB2aWV3XSBvZiB0aGlzLl92aXNpYmxlVmlld3MpLy8gSWYgYW4gaXRlbSBoYXMgYSB3aWR0aCBvZiAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBfdmlzaWJsZVZpZXdzLlxuICAgICAgICAvLyBSZW1vdmluZyBhbiBpdGVtIHdpdGggIHdpZHRoIG9mIDAgY2FuIGNhdXNlIGEgbG9vcCB3aGVyZSB0aGUgaXRlbSBnZXRzIGFkZGVkLCByZW1vdmVkLFxuICAgICAgICAvLyBhZGRlZCwgcmVtb3ZlZC4uLiBldGMgaW4gYSBsb29wLlxuICAgICAgICBpZiAoIWZpbmFsTWFwLmhhcyhrZXkpICYmIHZpZXcubGF5b3V0SW5mby5yZWN0LndpZHRoID4gMCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVtb3ZlZC5zZXQoa2V5LCB2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugc29tZXRoaW5nIHdlaXJkIGhhcHBlbmVkLCB3aGVyZSB3ZSBoYXZlIGEgdmlldyBidXQgbm9cbiAgICAgICAgICAgIC8vIGluaXRpYWwgbGF5b3V0IGluZm8sIHVzZSB0aGUgb25lIGF0dGFjaGVkIHRvIHRoZSB2aWV3LlxuICAgICAgICAgICAgaWYgKHZpZXcubGF5b3V0SW5mbykge1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLmhhcyh2aWV3LmxheW91dEluZm8ua2V5KSkgdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLnNldCh2aWV3LmxheW91dEluZm8ua2V5LCB2aWV3LmxheW91dEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRTaXplID0gbmV3ICgwLCAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVSZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCk7XG4gICAgICAgIHRoaXMuX3JldXNhYmxlVmlld3MgPSB7fTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZUxheW91dEluZm9zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGVudCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyID0gbmV3ICgwLCAkMzY0MTkxYjNkZWNmMzY5NyRleHBvcnQkNDQ1NWVlNmFmYjM4ZGNiYikoKTtcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSgwLCAwKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvblF1ZXVlID0gW107XG4gICAgICAgIHZhciBfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgIC8vIFNldCBvcHRpb25zIGZyb20gcGFzc2VkIG9iamVjdCBpZiBnaXZlblxuICAgICAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IChfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbikgIT09IG51bGwgJiYgX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uICE9PSB2b2lkIDAgPyBfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gOiA1MDA7XG4gICAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb24gPSBvcHRpb25zLmFuY2hvclNjcm9sbFBvc2l0aW9uIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3AgPSBvcHRpb25zLmFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3AgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkT3ZlcnNjYW4gPSBvcHRpb25zLnNob3VsZE92ZXJzY2FuICE9PSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIFtcbiAgICAgICAgICAgIFwiZGVsZWdhdGVcIixcbiAgICAgICAgICAgIFwic2l6ZVwiLFxuICAgICAgICAgICAgXCJsYXlvdXRcIixcbiAgICAgICAgICAgIFwiY29sbGVjdGlvblwiXG4gICAgICAgIF0paWYgKG9wdGlvbnNba2V5XSkgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiAkZmMwYjEzYjQ4NGFjMTE5NCRleHBvcnQkMTUwNWRiODJmZTM1N2U2NShvcHRzKSB7XG4gICAgbGV0IFt2aXNpYmxlVmlld3MsIHNldFZpc2libGVWaWV3c10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShbXSk7XG4gICAgbGV0IFtjb250ZW50U2l6ZSwgc2V0Q29udGVudFNpemVdID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkobmV3ICgwLCAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYykoKSk7XG4gICAgbGV0IFtpc0FuaW1hdGluZywgc2V0QW5pbWF0aW5nXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2lzU2Nyb2xsaW5nLCBzZXRTY3JvbGxpbmddID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCB2aXJ0dWFsaXplciA9ICgwLCAkOEQzbnIkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIpKCksIFtdKTtcbiAgICB2aXJ0dWFsaXplci5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgc2V0VmlzaWJsZVZpZXdzOiBzZXRWaXNpYmxlVmlld3MsXG4gICAgICAgIHNldFZpc2libGVSZWN0IChyZWN0KSB7XG4gICAgICAgICAgICB2aXJ0dWFsaXplci52aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICBvcHRzLm9uVmlzaWJsZVJlY3RDaGFuZ2UocmVjdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbnRlbnRTaXplOiBzZXRDb250ZW50U2l6ZSxcbiAgICAgICAgcmVuZGVyVmlldzogb3B0cy5yZW5kZXJWaWV3LFxuICAgICAgICByZW5kZXJXcmFwcGVyOiBvcHRzLnJlbmRlcldyYXBwZXIsXG4gICAgICAgIGJlZ2luQW5pbWF0aW9uczogKCk9PnNldEFuaW1hdGluZyh0cnVlKSxcbiAgICAgICAgZW5kQW5pbWF0aW9uczogKCk9PnNldEFuaW1hdGluZyhmYWxzZSksXG4gICAgICAgIGdldFNjcm9sbEFuY2hvcjogb3B0cy5nZXRTY3JvbGxBbmNob3JcbiAgICB9O1xuICAgIHZpcnR1YWxpemVyLmxheW91dCA9IG9wdHMubGF5b3V0O1xuICAgIHZpcnR1YWxpemVyLmNvbGxlY3Rpb24gPSBvcHRzLmNvbGxlY3Rpb247XG4gICAgdmlydHVhbGl6ZXIudHJhbnNpdGlvbkR1cmF0aW9uID0gb3B0cy50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgKDAsICQ4RDNuciR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLmFmdGVyUmVuZGVyKCk7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJDhEM25yJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT52aXJ0dWFsaXplci53aWxsVW5tb3VudCgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXSk7XG4gICAgbGV0IHNldFZpc2libGVSZWN0ID0gKDAsICQ4RDNuciR1c2VDYWxsYmFjaykoKHJlY3QpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLnZpc2libGVSZWN0ID0gcmVjdDtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyXG4gICAgXSk7XG4gICAgbGV0IHN0YXJ0U2Nyb2xsaW5nID0gKDAsICQ4RDNuciR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIuc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgICAgc2V0U2Nyb2xsaW5nKHRydWUpO1xuICAgIH0sIFtcbiAgICAgICAgdmlydHVhbGl6ZXJcbiAgICBdKTtcbiAgICBsZXQgZW5kU2Nyb2xsaW5nID0gKDAsICQ4RDNuciR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIuZW5kU2Nyb2xsaW5nKCk7XG4gICAgICAgIHNldFNjcm9sbGluZyhmYWxzZSk7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplclxuICAgIF0pO1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkOEQzbnIkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICB2aXJ0dWFsaXplcjogdmlydHVhbGl6ZXIsXG4gICAgICAgICAgICB2aXNpYmxlVmlld3M6IHZpc2libGVWaWV3cyxcbiAgICAgICAgICAgIHNldFZpc2libGVSZWN0OiBzZXRWaXNpYmxlUmVjdCxcbiAgICAgICAgICAgIGNvbnRlbnRTaXplOiBjb250ZW50U2l6ZSxcbiAgICAgICAgICAgIGlzQW5pbWF0aW5nOiBpc0FuaW1hdGluZyxcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiBpc1Njcm9sbGluZyxcbiAgICAgICAgICAgIHN0YXJ0U2Nyb2xsaW5nOiBzdGFydFNjcm9sbGluZyxcbiAgICAgICAgICAgIGVuZFNjcm9sbGluZzogZW5kU2Nyb2xsaW5nXG4gICAgICAgIH0pLCBbXG4gICAgICAgIHZpcnR1YWxpemVyLFxuICAgICAgICB2aXNpYmxlVmlld3MsXG4gICAgICAgIHNldFZpc2libGVSZWN0LFxuICAgICAgICBjb250ZW50U2l6ZSxcbiAgICAgICAgaXNBbmltYXRpbmcsXG4gICAgICAgIGlzU2Nyb2xsaW5nLFxuICAgICAgICBzdGFydFNjcm9sbGluZyxcbiAgICAgICAgZW5kU2Nyb2xsaW5nXG4gICAgXSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuXG5cblxuXG5leHBvcnQgeyRjNzRjZGE3ZDMxYWYxMjUzJGV4cG9ydCRjODQ2NzFmNDZkNmExY2EgYXMgTGF5b3V0LCAkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSBhcyBMYXlvdXRJbmZvLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSBhcyBQb2ludCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QgYXMgUmVjdCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMgYXMgU2l6ZSwgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEgYXMgUmV1c2FibGVWaWV3LCAkZmMwYjEzYjQ4NGFjMTE5NCRleHBvcnQkMTUwNWRiODJmZTM1N2U2NSBhcyB1c2VWaXJ0dWFsaXplclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ })

};
;